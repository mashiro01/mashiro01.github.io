<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mashiroの小站</title>
  
  
  <link href="http://localhost:4000/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2020-08-24T00:16:12.271Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Mashiroi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++：返回引用，指针还是值</title>
    <link href="http://localhost:4000/2020/08/24/C-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%80%BC/"/>
    <id>http://localhost:4000/2020/08/24/C-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%80%BC/</id>
    <published>2020-08-24T00:09:20.000Z</published>
    <updated>2020-08-24T00:16:12.271Z</updated>
    
    <content type="html"><![CDATA[<p>自c语言中的指针以来，内存的管理与使用一直是程序员的痛处。不恰当的指针使用常常会导致严重的内存错误，而随意地返回安全的对象和值却间接地导致了程序运行效率地下降</p><p>在C++中引入了引用(Reference)来化解指针所带来的难题，但是这也是建立在正确使用的基础之上的</p><blockquote><p>引用在C++中可以看作是自解引用的指针，两者的性质相同，在汇编代码上并无异处</p></blockquote><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;func() &#123;    int a &#x3D; 1;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于这个函数，可以看出我们的本意是想返回a的引用值，但是对于函数来是，其是动态生成的，在完成调用后其中的局部变量值就会在栈中被销毁，无法形成长久的引用关系，一般在编译的时候就会为我们抛出这样一个警告：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">main.cc:4:10: warning: reference to stack memory associated with local variable &#39;a&#39; returned [-Wreturn-stack-address]  return a;         ^1 warning generated.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以得到这样一个结论</p><blockquote><p>当返回局部变量时我们一定要返回值，同时较小的结构也可以用过值来进行返回</p></blockquote><h2 id="返回指针"><a href="#返回指针" class="headerlink" title="返回指针"></a>返回指针</h2><p>指针在C中是常用的一种返回手段，能直接返回结构对应的地址</p><p>但是在C++中除了数组之外，一般直接用引用来替代指针的作用</p><h2 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h2><blockquote><p>既然对于值我们可以任意返回而不易出错，问什么我们还要设计出返回指针或者是引用的形式呢?</p></blockquote><p>这里给出一个相对于普通变量来说更大的结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct Foo &#123;  int i;  &#x2F;&#x2F; 假设这里有许许多多你看不见的属性&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当我们调用这样一个函数时，其可返回类型为Foo的值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Foo f() &#123;    Foo a;    a.i &#x3D; 101;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于Foo很大，当我们使用f()的返回值，比如Foo foo = f();的时候，按照常理，f()的返回值会被赋予foo，这个过程可能会发生拷贝，导致性能下降。这时对返回结果进行优化就显得尤为重要</p><h3 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string &amp;func(const string &amp;s1, const string &amp;s2) &#123;    return s1 + s2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于引用来说其在调用或返回时不会再用一个新值来对原先的值进行拷贝，而是直接使用原先的值进行操作，并在返回时直接返回内存中这个值的引用，并不会发生拷贝，从而一定程度上提升了程序的性能</p><p>同时需要需要了解的是这种引用称为是左值引用</p><blockquote><p>所谓左值一般可以认为是变量，是能够随意被赋值并使用的值，也是只能放在等号左边的值</p></blockquote><p>因此对于一个非局部变量的值，我们可以使用引用来对其进行返回</p><h3 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h3><p>使用引用固然能在函数返回时提高程序的性能，但是如果我们想要返回一个较大结构的临时变量呢?是不是只能返回值呢?</p><p>显然结果并不是这样的，我们可以使用const关键字对引用进行修饰从而延长被引用对象的生命周期，比如使用<code>const Foo &amp;foo = f()</code>就是正确的</p><blockquote><p>Only local const references prolong the lifespan</p></blockquote><p>这里引用下大佬博客上总结的两点</p><ol><li>引用必须是静态的，也就是必须用const来修饰这个引用。这是因为函数的返回值属于右值，也就是（rvalue）。普通的引用是左值引用，也就是lvalue reference。左值引用不能指向右值引用，只有const的左值引用才能用来指向右值</li><li>本来f()的返回值是一个临时的变量，在它调用结束后，就应该销毁了。可是通过像这样const Foo&amp; foo = f();，把临时的返回值赋值给一个const左值引用，f()返回值并不会立即销毁。这等于是在const引用的作用域内，延长了f()返回值的存活时间</li></ol><blockquote><p>所谓右值就是等号右边的值，一般为函数的返回值或者是明确的数值，右值只能在等号右边，并不能作为左值并被赋值</p></blockquote><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用是C++11中新加入的内容，是一个尤为重要的概念，其主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能</p><p>相比于<code>&amp;</code>是对左值进行绑定，<code>&amp;&amp;</code>就是对右值进行一个绑定，我们可以这样完成绑定</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 左值引用int i &#x3D; 100;int &amp;a &#x3D; i;&#x2F;&#x2F; 右值引用int &amp;&amp;b &#x3D; 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>右值可以看作是一种特殊的匿名变量，通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</p><p>同时右值引用可以看作是加了const的左值引用，其自身是一个左值，能够被任意修改，而其本质却是临时变量的右值，所以左值引用可以指向一个右值引用，而右值引用去不能被另外一个右值引用所指向</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;&amp;i &#x3D; 100;&#x2F;&#x2F; 正确做法i++;int tmp &#x3D; 200; i &#x3D; tmp;int &amp;left &#x3D; i;&#x2F;&#x2F; 错误做法int &amp;&amp;j &#x3D; 200;j &#x3D; i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a><br><a href="https://marvinsblog.net/post/2018-08-07-cplusplus-return-value-or-reference/">C++：关于函数返回的一件小事——是返回值还是返回引用？</a><br><a href="https://stackoverflow.com/questions/2784262/does-a-const-reference-class-member-prolong-the-life-of-a-temporary">Does a const reference class member prolong the life of a temporary?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自c语言中的指针以来，内存的管理与使用一直是程序员的痛处。不恰当的指针使用常常会导致严重的内存错误，而随意地返回安全的对象和值却间接地导致了程序运行效率地下降&lt;/p&gt;
&lt;p&gt;在C++中引入了引用(Reference)来化解指针所带来的难题，但是这也是建立在正确使用的基础之上</summary>
      
    
    
    
    <category term="c/c++" scheme="http://localhost:4000/categories/c-c/"/>
    
    
    <category term="返回值的优化" scheme="http://localhost:4000/tags/%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>WSL2下kernel header的安装</title>
    <link href="http://localhost:4000/2020/08/24/wsl2%E4%B8%8B%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://localhost:4000/2020/08/24/wsl2%E4%B8%8B%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-24T00:01:08.000Z</published>
    <updated>2020-08-24T00:04:03.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来正常的linux发行版只要安装<code>linux-headers-$(uname -r)</code>就能装上内核头文件，但wsl2作为一个不一般的linux发行版，并没有直接给出安装包，要手动安装才能正常使用</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>先去github上找到对应版本的内核源码，我这里使用的是<code>4.19.121-microsoft-standard</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base)  ⚡ root@404-NOT-FOUND  ~&#x2F;forExtract&#x2F;kernel  uname -r4.19.121-microsoft-standard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那我就应该下载这个版本: <a href="https://github.com/microsoft/WSL2-Linux-Kernel/releases/tag/4.19.121-microsoft-standard">https://github.com/microsoft/WSL2-Linux-Kernel/releases/tag/4.19.121-microsoft-standard</a></p><ul><li><p>安装依赖</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt install libelf-dev build-essential pkg-configapt install bison build-essential flex libssl-dev libelf-dev bc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zvxf 4.19.121-microsoft-standard.tar.gzcd WSL2-Linux-Kernel-4.19.121-microsoft-standard.tar.gzzcat &#x2F;proc&#x2F;config.gz &gt; .configmake -j $(nproc)               &#x2F;&#x2F;Compile the kernel and modulesmake -j $(nproc) modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>编译完成后创建软链接即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln ~&#x2F;kernel&#x2F;WSL2-Linux-Kernel-4.19.121-microsoft-standard &#x2F;usr&#x2F;src&#x2F;linux-headers-4.19.121-microsoft-standard&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来正常的linux发行版只要安装&lt;code&gt;linux-headers-$(uname -r)&lt;/code&gt;就能装上内核头文件，但wsl2</summary>
      
    
    
    
    <category term="wsl2调教" scheme="http://localhost:4000/categories/wsl2%E8%B0%83%E6%95%99/"/>
    
    
    <category term="kernel" scheme="http://localhost:4000/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>初探内核模块</title>
    <link href="http://localhost:4000/2020/08/24/%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2/"/>
    <id>http://localhost:4000/2020/08/24/%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2/</id>
    <published>2020-08-23T16:29:17.000Z</published>
    <updated>2020-08-23T16:30:36.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正好今天开始开始看《Linux内核设计与实现》这本书，就以Hello,world开个头吧</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 模块所需头文件#include &lt;linux&#x2F;init.h&gt;#include &lt;linux&#x2F;module.h&gt;#include &lt;linux&#x2F;kernel.h&gt;#include &lt;linux&#x2F;moduleparam.h&gt;&#x2F;&#x2F; 许可证书MODULE_LICENSE(&quot;GPL&quot;);static int __init mod_init(void) &#123;    printk(KERN_ALERT &quot;Hello, World\n&quot;);    return 0;&#125;static void __exit mod_exit(void) &#123;    printk(KERN_ALERT &quot;Goodbye\n&quot;);&#125;module_init(mod_init);module_exit(mod_exit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-m :&#x3D; hello.oCURRENT_PATH :&#x3D; $(shell pwd)VERSION_NUM :&#x3D; $(shell uname -r)LINUX_PATH :&#x3D; &#x2F;usr&#x2F;src&#x2F;linux-headers-$(VERSION_NUM)all:make -C $(LINUX_PATH) M&#x3D;$(CURRENT_PATH) modulesclean:make -C $(LINUX_PATH) M&#x3D;$(CURRENT_PATH) clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到的是内核模块的输出与标准输出有稍许不同的地方：</p><ul><li><code>printk</code>中<code>KERN_*</code>代表了优先级，与输出内容隔一个空格</li><li><code>printf</code>就是标准输出，只是调用系统函数输出字符串</li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>直接make得到一大串文件</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.├── Makefile├── Module.symvers├── hello.c├── hello.ko├── hello.mod.c├── hello.mod.o├── hello.o└── modules.order<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里输出的.o文件并不能直接运行，为REL类型</p></blockquote><p><code>*.ko</code>即为我们所需的内核模块，<code>insmod $&#123;name&#125;.ko</code>将模块加载进内核</p><p>用dmesg查看输出</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">[46478.783149] WSL2: Performing memory compaction.[46539.789768] WSL2: Performing memory compaction.[46660.796831] WSL2: Performing memory compaction.[46781.803469] WSL2: Performing memory compaction.[46902.810284] WSL2: Performing memory compaction.[46963.817192] WSL2: Performing memory compaction.[47007.007476] Hello, World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>rmmod $(name)</code>退出该模块</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">[53723.654584] WSL2: Performing memory compaction.[53784.665033] WSL2: Performing memory compaction.[53845.672471] WSL2: Performing memory compaction.[53906.679157] WSL2: Performing memory compaction.[54027.685937] WSL2: Performing memory compaction.[54054.799471] Goodbye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正好今天开始开始看《Linux内核设计与实现》这本书，就以Hello,world开个头吧&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="linux kernel" scheme="http://localhost:4000/categories/linux-kernel/"/>
    
    
    <category term="kernel" scheme="http://localhost:4000/tags/kernel/"/>
    
    <category term="module" scheme="http://localhost:4000/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>c/c++判断溢出</title>
    <link href="http://localhost:4000/2020/08/23/c%E5%88%A4%E6%96%AD%E6%BA%A2%E5%87%BA/"/>
    <id>http://localhost:4000/2020/08/23/c%E5%88%A4%E6%96%AD%E6%BA%A2%E5%87%BA/</id>
    <published>2020-08-23T15:51:26.000Z</published>
    <updated>2020-08-24T00:15:55.383Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int isAddOverflow(int a, int b) &#123;    int c &#x3D; 0;    __asm &#123;        mov eax, a        add eax, b        jo overflowed        xor eax, eax        jmp no_overflowed    overflowed:        mov eax, 1        mov c, eax    no_overflowed:    &#125;    return c;&#125;int main() &#123;    cout &lt;&lt; isAddOverflow(0x7fffffff, 1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用汇编判读OF标志位是否变化即可得到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-cpp&quot; data-language=&quot;cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int i</summary>
      
    
    
    
    <category term="c/c++" scheme="http://localhost:4000/categories/c-c/"/>
    
    
    <category term="溢出判断" scheme="http://localhost:4000/tags/%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://localhost:4000/2020/08/23/hello-world/"/>
    <id>http://localhost:4000/2020/08/23/hello-world/</id>
    <published>2020-08-23T15:32:04.288Z</published>
    <updated>2020-08-23T15:32:04.288Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
