<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mashiroの小站</title>
  
  
  <link href="https://mashiro01.github.io/atom.xml" rel="self"/>
  
  <link href="https://mashiro01.github.io/"/>
  <updated>2020-08-24T06:46:23.762Z</updated>
  <id>https://mashiro01.github.io/</id>
  
  <author>
    <name>Mashiroi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解计算机操作系统(二) -- 信息</title>
    <link href="https://mashiro01.github.io/2020/08/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C/"/>
    <id>https://mashiro01.github.io/2020/08/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C/</id>
    <published>2020-08-24T06:31:19.000Z</published>
    <updated>2020-08-24T06:46:23.762Z</updated>
    
    <content type="html"><![CDATA[<p>现代计算机主要使用二进制来表示信息。当每一个二进制数字<code>(位[bit])</code>被组合起来后，再加上某种解释，就能够表示出<code>任何有限集合的元素</code></p><p>同时我们需要注意的是，能够用来表示位是<strong>有限的</strong>，且其在不同架构的计算机中是不同的，如果运算结果或者参与运算的元素<strong>超过了这一限制</strong>，运算就会发生<code>溢出</code>，产生某些神奇的错误</p><h2><span id="xin-xi-cun-chu">信息存储</span><a href="#xin-xi-cun-chu" class="header-anchor">#</a></h2><p>计算机存储的最小单位为比特(bit)，<strong>8bit</strong>组成一个<code>字节</code>(byte)，为最小的可寻址的内存单位</p><p>对于程序来说，其会将内存视作<code>字节数组</code>，也就是<code>虚拟内存</code>，内存的每一个字节均会有一个对应的<code>地址</code></p><blockquote><p>对于c中的指针，其值均指向某个存储块的第一个字节的虚拟地址</p></blockquote><h3><span id="shi-liu-jin-zhi-biao-shi-fa">十六进制表示法</span><a href="#shi-liu-jin-zhi-biao-shi-fa" class="header-anchor">#</a></h3><p>对于字节来说，其由8个比特组成，用二进制表示的话太长了，用十进制表示的话转化转换不方便，而用十六进制的话恰好<strong>每四个字节</strong>能够划分为一组，表示十分方便</p><p><img src="/images/csapp/chapter2/hex.png" alt="hex"></p><p><img src="/images/csapp/chapter2/hexTrans.png" alt="hex"></p><h3><span id="zi-shu-ju-da-xiao">字数据大小</span><a href="#zi-shu-ju-da-xiao" class="header-anchor">#</a></h3><p>对于不同架构的机器来说，其能访问的<code>虚拟地址空间</code>的长度也不同</p><p>例如对于x86架构的机器来说，其能访问$1 - (2^{32} - 1)$范围的地址，为4GB，而对x64架构来说则能访问$1 - (2^{64} - 1)$范围，约为16EB大小的空间</p><blockquote><p>不同的字长是由于寄存器长度的不同而形成的，同时不同长度之间向下兼容</p></blockquote><p><img src="/images/csapp/chapter2/c_lang.png" alt="c"></p><blockquote><p>在编写程序时需要注意不同架构下的兼容性问题</p></blockquote><h3><span id="xun-zhi-yu-zi-jie-shun-xu">寻址与字节顺序</span><a href="#xun-zhi-yu-zi-jie-shun-xu" class="header-anchor">#</a></h3><p>对于一个复杂的应用程序来说，我们必须考虑如何在内存中存储这些对象</p><blockquote><p>对于一个w位的整数来说，其位表示为$[x_{w-1}, x_{w-2}, … , x_1, x_0]$，其中<code>最高有效字节</code>包括$[x_{w-1}, … , x_{w-8}]$，<code>最低有效字节</code>为$[x_7, … , x_1]$</p></blockquote><p>对于对象的排列来说有两种顺序</p><ul><li>最低有效字节在前，称为<code>小端法</code></li><li>最高有效字节在前，称为<code>大端序</code></li></ul><p><img src="/images/csapp/chapter2/sequence.png" alt="seq"></p><p>查看大小端可以用c语言来查看</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;void show_bytes(byte_pointer start, size_t len) &#123;    for (size_t i &#x3D; 0; i &lt; len; i++) &#123;        printf(&quot;%.2x&quot;, start[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main() &#123;    show_bytes(100, sizeof(int));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="bu-er-dai-shu">布尔代数</span><a href="#bu-er-dai-shu" class="header-anchor">#</a></h3><p>布尔代数是为了研究<code>逻辑推理</code>的基本原则，将逻辑值<code>True</code>和<code>False</code>分别编码为<code>0</code>和<code>1</code></p><p>同时布尔代数支持逻辑上的运算，即<code>非，异或，与，或</code></p><p><img src="/images/csapp/chapter2/boolen.png" alt="bool"></p><p>在将布尔代数拓展为<code>位向量</code>之后，这种运算依然成立</p><blockquote><p>型如$[a_{w-1}, … , a_0]$的编码集合称为是位向量</p></blockquote><h3><span id="wei-ji-yun-suan">位级运算</span><a href="#wei-ji-yun-suan" class="header-anchor">#</a></h3><blockquote><p>和布尔运算一样吧</p></blockquote><h3><span id="luo-ji-yun-suan">逻辑运算</span><a href="#luo-ji-yun-suan" class="header-anchor">#</a></h3><p>与位级运算不同，这个逻辑运算是指<strong>整体逻辑上</strong>的成立与否，能够以True或False的形式进行输出</p><p>一般提供了<code>||(or)</code>, <code>&amp;&amp;(and)</code>, 和<code>!(not)</code>三种逻辑运算方式</p><p><img src="/images/csapp/chapter2/logic.png" alt="logic"></p><h3><span id="yi-wei-yun-suan">移位运算</span><a href="#yi-wei-yun-suan" class="header-anchor">#</a></h3><p><code>移位</code>表示位向量中每个比特向某个方向整体移动n位，自动舍弃超出的位，并在不足的位置上自动<strong>补足</strong></p><p>对于右移来说，其分为以下两种类型</p><ul><li>逻辑右移：向左端补齐0</li><li>算术右移：在左端补齐最高有效位的值</li></ul><h2><span id="zheng-shu-biao-shi">整数表示</span><a href="#zheng-shu-biao-shi" class="header-anchor">#</a></h2><h3><span id="zheng-xing-shu-zi-lei-xing">整型数字类型</span><a href="#zheng-xing-shu-zi-lei-xing" class="header-anchor">#</a></h3><p>对于c来说，c中具有多种整型数据类型，每种关键字均能用关键字来指定大小</p><p><img src="/images/csapp/chapter2/interger_m32_range.png" alt="m32"></p><p><img src="/images/csapp/chapter2/interger_m64_range.png" alt="m64"></p><blockquote><p>可以看到正数和负数的取值范围是不同的，这与负数的表示方式相关</p></blockquote><h3><span id="zheng-xing-bian-ma">整型编码</span><a href="#zheng-xing-bian-ma" class="header-anchor">#</a></h3><h4><span id="wu-fu-hao-shu-zi-de-bian-ma">无符号数字的编码</span><a href="#wu-fu-hao-shu-zi-de-bian-ma" class="header-anchor">#</a></h4><p>对于一个整形数据来说，我们可以将其的每一位组合成一个位向量$\vec x$，且内部结构为$[x_{w-1}, … , x_0]$</p><p>这样看来我们可以这样来定义无符号数(使用$B2U_w$函数来实现)</p><script type="math/tex; mode=display">B2U_w(\vec{x}) = \sum_{i=0}^{w-1}x_i2^i</script><p>需要我们注意的是</p><ul><li>当我们指定一个数量是无符号类型时，那么其最高位的1或0，和其它位一样，用来表示该数的大小</li></ul><h4><span id="you-fu-hao-shu-zi-de-bian-ma">有符号数字的编码</span><a href="#you-fu-hao-shu-zi-de-bian-ma" class="header-anchor">#</a></h4><p>与无符号数字相似，其也是通过位的运算所得出的结果，但是最高位不再指定数字的大小，而是表示符号</p><p>这种表示方式称为是<code>补码</code></p><script type="math/tex; mode=display">B2U_w(\vec{x}) = -x_{w-1} + \sum_{i=0}^{w-2}x_i2^i</script><h3><span id="zheng-xing-biao-shi-de-te-dian">整形表示的特点</span><a href="#zheng-xing-biao-shi-de-te-dian" class="header-anchor">#</a></h3><p>对于<code>WORD</code>类型的数字来说</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Decimal</th><th style="text-align:center">Hex</th><th style="text-align:center">Binary</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">UMax</td><td style="text-align:center">65535</td><td style="text-align:center">FF FF</td><td style="text-align:center">1111 1111 1111 1111</td><td style="text-align:center">2^16 - 1</td></tr><tr><td style="text-align:center">TMax</td><td style="text-align:center">32767</td><td style="text-align:center">7F FF</td><td style="text-align:center">0111 1111 1111 1111</td><td style="text-align:center">2^15 - 1</td></tr><tr><td style="text-align:center">TMin</td><td style="text-align:center">-32768</td><td style="text-align:center">80 00</td><td style="text-align:center">1000 0000 0000 0000</td><td style="text-align:center">-2^15</td></tr><tr><td style="text-align:center">-1</td><td style="text-align:center">-1</td><td style="text-align:center">FF FF</td><td style="text-align:center">1111 1111 1111 1111</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">00 00</td><td style="text-align:center">0000 0000 0000 0000</td></tr></tbody></table></div><p>拓展到任意长度的均可这样表示</p><p>可以得到</p><ul><li>$|T_{min}|=T_{max}+1$</li><li>$|U_{max}|=2*T_{max}+1$</li></ul><p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换</p><ul><li>$U2B(x)=B2U−1(x)$</li><li>$T2B(x)=B2T−1(x)$</li></ul><h3><span id="lei-xing-zhuan-huan">类型转换</span><a href="#lei-xing-zhuan-huan" class="header-anchor">#</a></h3><p><img src="https://wdxtub.com/images/14609257940557.jpg" alt="link"></p><p>当我们在有符号和无符号类型之间进行转换时</p><ul><li>位值不变，只是改变了解释这些位的方式</li><li>如果一个表达式既包含有符号数也包含无符号数，那么会被隐式转换成无符号数进行比较</li></ul><p>其余情况下按着这个数轴进行一一对应</p><p><img src="/images/csapp/chapter2/trans.png" alt="trans"></p><blockquote><p>在编写c语言程序时务必要注意数字类型的比较</p><p>不只是整型之间的转换，c中整型向size_t, char等的类型进行转换时也要注意符号带来的影响</p></blockquote><h3><span id="zeng-yu-jian">增与减</span><a href="#zeng-yu-jian" class="header-anchor">#</a></h3><p>增与减都代表了程序自身理解内存方式的变化</p><h4><span id="tuo-zhan-shu-zi-de-wei-biao-shi">拓展数字的位表示</span><a href="#tuo-zhan-shu-zi-de-wei-biao-shi" class="header-anchor">#</a></h4><ul><li>无符号数字只要向表示的开头加<code>0</code>即可</li><li>有符号数字需要向表示的开头加<code>1</code></li></ul><h4><span id="jie-qu-shu-zi">截取数字</span><a href="#jie-qu-shu-zi" class="header-anchor">#</a></h4><ul><li>对于无符号数字，丢弃相应位数，相当于 $x mod 2^k$</li><li>对于有符号数字，丢弃相应位数，最高位作为符号位继续表示</li></ul><h3><span id="zheng-xing-yun-suan">整型运算</span><a href="#zheng-xing-yun-suan" class="header-anchor">#</a></h3><h4><span id="yi-chu">溢出</span><a href="#yi-chu" class="header-anchor">#</a></h4><p>数值的范围可以看作是一个首尾相接的圆，超出了返回就会向相接的部分发生变化</p><ul><li>从最大正数部分溢出到负数称为是<code>正溢</code></li><li>从最小负数部分溢出到正数称为是<code>负溢</code></li></ul><h4><span id="yun-suan">运算</span><a href="#yun-suan" class="header-anchor">#</a></h4><blockquote><p>公式部分就不想写了，感觉看了也没啥用。。。</p></blockquote><p>整数运算就是<strong>位的运算</strong>，也是一种<strong>模运算形式</strong></p><p>特别是乘法与除法，在不涉及浮点数时，其本质在O1优化下可以很容易地看出是<code>加法与减法的结合体</code></p><h2><span id="fu-dian-shu">浮点数</span><a href="#fu-dian-shu" class="header-anchor">#</a></h2><p>浮点数的出现补足了计算机数值运算的<code>&quot;空缺&quot;</code>，能表示出接近0的数字，也能表示出非常大的数字，这些都是浮点数的特殊结构所带来的特别之处</p><blockquote><p>需要注意的是，浮点数的特殊结构决定了其只能是<code>近似结果</code></p></blockquote><h3><span id="fu-dian-shu-de-biao-shi">浮点数的表示</span><a href="#fu-dian-shu-de-biao-shi" class="header-anchor">#</a></h3><h4><span id="ding-dian-biao-shi-fa">定点表示法</span><a href="#ding-dian-biao-shi-fa" class="header-anchor">#</a></h4><p>作为特殊的一类数字，我们仍能使用整数的表示方法来对浮点数进行编码</p><p>以点为界，左为整数的表示法，从右开始每位的权由<code>-1</code>依次减一，这就表示出了一个简单的浮点数</p><script type="math/tex; mode=display">d = \sum_{i=-n}^{m}10^{i} * d_{i}</script><p><img src="/images/csapp/chapter2/simpleFloat.png" alt="simpleFloat"></p><p>同时很明显的是，这样只能表示出形如$x * 2^y$的数字，对于0.20之类的小数并不能准确表示</p><h4><span id="ieee-754">IEEE 754</span><a href="#ieee-754" class="header-anchor">#</a></h4><p><code>IEEE 754</code>标准用$V=(-1)^s<em>M</em>2^e$来表示一个数字</p><ul><li><code>符号s</code>，决定了最后的符号</li><li><code>尾数</code>，M是一个二进制小数，范围是</li><li><code>阶码</code>，对浮点数加权</li></ul><p><img src="/images/csapp/chapter2/IEEEE.png" alt="IEEE"></p><p>同时根据给出的exp的值，被编码的值可以分为三种不同的情况</p><p><img src="/images/csapp/chapter2/exp.png" alt="exp"></p><blockquote><p>所以说0.1+0.2为啥不等于0.3就是这个原因</p></blockquote><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor">#</a></h2><p><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/">【读薄 CSAPP】壹 数据表示</a></p><hr><h2><span id="dui-ying-lab">对应Lab</span><a href="#dui-ying-lab" class="header-anchor">#</a></h2><ul><li>[ ] datalab</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现代计算机主要使用二进制来表示信息。当每一个二进制数字&lt;code&gt;(位[bit])&lt;/code&gt;被组合起来后，再加上某种解释，就能够表示出&lt;code&gt;任何有限集合的元素&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同时我们需要注意的是，能够用来表示位是&lt;strong&gt;有限的&lt;/strong</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://mashiro01.github.io/categories/CSAPP/"/>
    
    
    <category term="信息表示" scheme="https://mashiro01.github.io/tags/%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机操作系统(一) -- 计算机系统</title>
    <link href="https://mashiro01.github.io/2020/08/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80/"/>
    <id>https://mashiro01.github.io/2020/08/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80/</id>
    <published>2020-08-24T06:30:06.000Z</published>
    <updated>2020-08-24T06:32:00.095Z</updated>
    
    <content type="html"><![CDATA[<p>这里先给出一段c的代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;Hello,World!&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出这就是一段普通的字符，并没有什么特别之处，那么这又是怎么编译成能够被运行的程序呢?</p><h2><span id="cheng-xu-bei-fan-yi-cheng-qi-ta-de-ge-shi">程序被翻译成其他的格式</span><a href="#cheng-xu-bei-fan-yi-cheng-qi-ta-de-ge-shi" class="header-anchor">#</a></h2><p>对于高级程序语言来说，其能够被<code>编译器</code>转化为一系列<code>低级机器语言</code>指令，并且之后被按照一种<code>可执行目标程序</code>打包为<code>二进制文件</code>，这样就完成了程序的编译</p><p><img src="/images/csapp/chapter1/sys.png" alt="sys"></p><ul><li><p>预处理阶段<br>预处理器将引用的库文件进行<code>展开</code>，并对原c程序进行修改，得到完整的源程序</p></li><li><p>编译阶段<br>编译器将<code>.i</code>文件翻译为低级机器语言，得到一个包含<code>汇编语言程序</code>的文本文件</p></li><li><p>汇编阶段<br>汇编器将汇编语言程序翻译为机器语言，并打包在一个后缀为<code>.o</code>的二进制文件中</p></li><li><p>链接阶段<br>链接器将其他外部引用的函数所编译成的.o文件与前一步编译好的文件结合起来，形成<code>可执行目标文件</code></p></li></ul><blockquote><p>可以通过gcc来编译并查看这些中间文件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc hello.c -save-items -m32 -o hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2><span id="cheng-xu-zai-xi-tong-zhong-de-yun-xing">程序在系统中的运行</span><a href="#cheng-xu-zai-xi-tong-zhong-de-yun-xing" class="header-anchor">#</a></h2><h3><span id="xi-tong-de-ying-jian-zu-cheng">系统的硬件组成</span><a href="#xi-tong-de-ying-jian-zu-cheng" class="header-anchor">#</a></h3><p><img src="/images/csapp/chapter1/bus.png" alt="bus"></p><ol><li><p>总线<br>总线是系统中携带信息字节并在各个部件间传递的设备</p></li><li><p>I/O设备<br>I/O设备是系统与外界世界的联系通道，且每一个I/O设备均通过一个<code>控制器</code>或<code>适配器</code>与I/O总线相连</p></li><li><p>主存<br>主存是临时存储设备，能够存储程序运行期间处理的数据和程序本体</p></li><li><p>处理器<br>CPU能够不断地处理来自主存中的指令，在任何时刻其中的<code>程序计数器</code>均指向某条机器语言指令</p></li></ol><h3><span id="cheng-xu-de-yun-xing-guo-cheng">程序的运行过程</span><a href="#cheng-xu-de-yun-xing-guo-cheng" class="header-anchor">#</a></h3><p>首先当我们从键盘等I/O设备输入命令时，shell会先把字符逐一读入寄存器，再将其放到内存中</p><p><img src="/images/csapp/chapter1/read.png" alt="read"></p><p>之后在完成输入后，shell会从磁盘中加载我们所输入的文件到主存中</p><p><img src="/images/csapp/chapter1/load.png" alt="load"></p><p>在完成加载到主存中后，程序就能够执行并进行输出了</p><p><img src="/images/csapp/chapter1/run.png" alt="run"></p><h2><span id="cao-zuo-xi-tong-yu-ying-jian">操作系统与硬件</span><a href="#cao-zuo-xi-tong-yu-ying-jian" class="header-anchor">#</a></h2><h3><span id="gao-su-huan-cun">高速缓存</span><a href="#gao-su-huan-cun" class="header-anchor">#</a></h3><p>不同I/O设备间的速度是不同的，同时与系统内部硬件的速度更是有很大的区别</p><p>为了使不同速度的硬件能够互相协调，我们引入了<code>高速缓存</code>这个结构，同时每个计算机系统中的存储设备均被组织成了一个存储器层次结构</p><p><img src="/images/csapp/chapter1/storageLevel.png" alt="storage"></p><h3><span id="cao-zuo-xi-tong-guan-li-ying-jian">操作系统管理硬件</span><a href="#cao-zuo-xi-tong-guan-li-ying-jian" class="header-anchor">#</a></h3><p>操作系统位于<code>硬件和应用程序之间</code>，是用户通过应用程序操作硬件的一种<code>接口</code>，同时能够协调两边的活动</p><p><img src="/images/csapp/chapter1/operatingSystem.png" alt="system"></p><p>操作系统主要有以下两种作用</p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供一种机制来控制复杂而大不相同的低级硬件设施</li></ol><h4><span id="jin-cheng">进程</span><a href="#jin-cheng" class="header-anchor">#</a></h4><p><code>进程</code>是操作系统对正在运行程序的一种<code>抽象</code>。在一个操作系统上能够同时运行多个进程</p><p>对于单核处理器来说，不同进程间的指令是交错执行的，这个称为是<code>并发运行</code>，同时这种交错执行的机制称为是<code>上下文切换</code></p><p><img src="/images/csapp/chapter1/change.png" alt="exchange"></p><p>可以看出上下文切换是在<code>内核态</code>的时候所发生的，操作系统能够保存前一进程的状态，并待另一进程运行完成后恢复前一进程的数据</p><p>同时进程能够通过<code>系统调用</code>(system call)来调用操作系统内的操作</p><h4><span id="xian-cheng">线程</span><a href="#xian-cheng" class="header-anchor">#</a></h4><p>一个进程能够由多个称为<code>线程</code>的执行单元组成，同时线程之间能够共享数据</p><h4><span id="xu-ni-nei-cun">虚拟内存</span><a href="#xu-ni-nei-cun" class="header-anchor">#</a></h4><p><a href="https://www.cnblogs.com/yaoxiaowen/p/7805964.html">https://www.cnblogs.com/yaoxiaowen/p/7805964.html</a></p><h4><span id="wen-jian">文件</span><a href="#wen-jian" class="header-anchor">#</a></h4><p>文件就是一种<code>字节序列</code>，任何<strong>一种I/O设备均可以被看作是一种文件</strong>，同时输入输出即可通过调用这些文件来实现</p><h4><span id="wang-luo">网络</span><a href="#wang-luo" class="header-anchor">#</a></h4><p><img src="/images/csapp/chapter1/netAdapter.png" alt="net"></p><p>网络适配器也是一种I/O设备，通过交互能够将网络通信内容<strong>加载到主存</strong>当中</p><h2><span id="cheng-xu-kuai-su-yun-xing-de-ji-chu">程序快速运行的基础</span><a href="#cheng-xu-kuai-su-yun-xing-de-ji-chu" class="header-anchor">#</a></h2><p>这里我们先要区分开并发和并行的含义</p><ul><li>并发：指可以同时具有多个活动的系统</li><li>并行：指使用并发使系统运行地更快</li></ul><h3><span id="xian-cheng-ji-bing-fa">线程级并发</span><a href="#xian-cheng-ji-bing-fa" class="header-anchor">#</a></h3><p>并发的实质是<strong>一个物理CPU</strong>(也可以多个物理CPU)在若干道程序之间<code>多路复用</code>，并发是对有限物理资源强制行使多用户共享以提高效率。</p><blockquote><p>并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状</p></blockquote><h3><span id="zhi-ling-ji-bing-xing">指令级并行</span><a href="#zhi-ling-ji-bing-xing" class="header-anchor">#</a></h3><p><code>并行</code>指两个或两个以上事件或活动在<strong>同一时刻发生</strong>。在多道程序环境下，并行性使多个程序同一时刻可在<strong>不同</strong>CPU上<strong>同时</strong>执行</p><blockquote><p>当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行</p></blockquote><h3><span id="chuan-xing">串行</span><a href="#chuan-xing" class="header-anchor">#</a></h3><p>除了并行之外，我们还有<code>串行</code>这种任务的执行方式</p><p>串行是指多个任务时，各个任务按<strong>顺序执行</strong>，完成一个之后才能进行下一个</p><h3><span id="tong-bu-he-yi-bu">同步和异步</span><a href="#tong-bu-he-yi-bu" class="header-anchor">#</a></h3><p>指的是能否开启<code>新的线程</code>。同步不能开启新的线程，异步可以。异步和同步是相对的</p><ul><li><code>同步</code>就是<strong>顺序执行</strong>，执行完一个再执行下一个，需要等待、协调运行</li><li><code>异步</code>就是彼此独立, 在等待某事件的过程中继续做自己的事，<strong>不需要等待</strong>这一事件完成后再工作，减小IO阻塞对程序运行速度的减慢</li></ul><h3><span id="xiao-jie">小结</span><a href="#xiao-jie" class="header-anchor">#</a></h3><p><strong>线程就是实现异步的一个方式</strong></p><p>异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。异步和多线程并不是一个同等关系, 异步是<code>最终目的</code>, 多线程只是我们<strong>实现异步的一种手段</strong></p><p>异步是当一个调用请求发送给被调用者, 而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或者交给另外的进程来处理</p><h2><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://juejin.im/post/6844904159292948487">并发，并行，串行，同步，异步？</a></li><li><a href="https://www.cnblogs.com/yaoxiaowen/p/7805661.html">什么是内存（一）：存储器层次结构</a></li><li><a href="https://www.cnblogs.com/yaoxiaowen/p/7805964.html">什么是内存(二)：虚拟内存</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里先给出一段c的代码&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot; data-language=&quot;c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() &amp;#12</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://mashiro01.github.io/categories/CSAPP/"/>
    
    
    <category term="系统总览" scheme="https://mashiro01.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Internet地址结构</title>
    <link href="https://mashiro01.github.io/2020/08/24/Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/"/>
    <id>https://mashiro01.github.io/2020/08/24/Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</id>
    <published>2020-08-24T06:26:33.000Z</published>
    <updated>2020-08-24T06:27:00.392Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="26c69a8930184d0929917e7d2dee0f85f5f11a88573e8f56bee39b74f680b2fe">6da47b4724abb78227bccab392027efb2189eb3d660e641d1508d22d529f394c904cc0feda7d3e2716d7c3655a9bdd42ad2f2a7aaf1ac3f7f40863f581dbfd3fa4b55e73af1a1d20c5f4fb8a2d4e644db20ada4a9f0d09d5941261ed3318717f5d0bc9913186f8bd01917c1d7e618a4282dee6c650752a1c33c19a8e7b36df0bacbf1a1be3afdbf795f5e98d8ba4098d9e78bc841deab354ddbb1a0cb637ca1e0cb5328285f9186c74d3e5e6e648445a84e3a1bd198ca37f7f06444177d6d8fffb41d208bc1d6a10104076ad21452233c58bc63a3ba84d1f6954d5abcbc9c49a8b7e0b1884a3850c2d8b8b193a81fc16e01314a80571243b84dfa2252c6d12cd2f854d9ce757db65668fe774f9aaa551be5abbb8c412eeafc9f2df8b4b077a8b4a27ae04feec981c06b0ea7a9f8e0d91ea808dd4906b66eb2d773f004c090ec9102889bdeee29ccf2cee647ccdcc3c860b238436fb7f60022f5c99dce3288c4bcf17b05fc7ec49629759f055eae995c5826cab3a43d1d27126ab8e7f471b45a54767b45f5b3abdfe3ef62647fdaba4ff71e823ef23e5fe449cf283f4ff9c212e14157a880ad540c2a036587b1c4e92d0f011cbfcec91e3ca0f023f16a8465300cd78dd007a05012dbb82fb1509b7bd9df14e283f36880f8412ee5c89a70d0a04f9e90debab73ee907e3b0004837a2fec59fdbd1a69c909c62c4fad513b803db1fafd090309e1a50551c0d0fa20eccd386b5fde28c4b7c03de2d9080fc29b698567dcd04eb47a17d0df02814009983b0797b4f7ea96e967601826a65672aa70a7c46ecf8f79d9c59b1c3307f9155913504510ad9287b3e6199e98a520b6f28355f9c2ab06cd2e2853892c2fc84ece5dfc630ce96a0fe3d2f80db4838ebcc6e3ce64e185f89a4eec0b6396062ff0c0b07b9e224c6e748f95b2e931a450ecaf223f61067543de6aba611728cf950bab52eba6c6977fe9175475fc88b7ea1ea559202c89ade503dddb018a3d79200908253fbdd17198e5c7b452fe0ca20b5eee5ad45b9299d6bfb67d4ba791f351aa9a35d8b0d7d7960a0b69c891c1e9f21fa6eb4dd66c79d15fe17cc86f7b70b636d347bca4c2cd02bc44f5a89f3d20716df0ae34d46791f1062e0304fdeb9c845d0f9679bca7e982ef6fbf646c2b38f415fe316c23a76e8ccc3560323086dffe9ec3f4a8543912e13c92d19f32a4f53c41609fc4903aa00efc05889e46daabd928b658efe9ace3b9df86258bec5771a9d1f944b241a8810cf867ef4290f4d855709bdeb393aa9ff0b001e2ab3eebf865c5fa8806a968abd6f3ddb889a80fd2afaceb5efcaa5f9dc8bb99951f978b44519a2af8d2e667bab85fccf21f9ba5d78051c38dc62177eba21d3027453ac53aefed5cea6cf214a8e4adcc5520f5bada8d9aad6ce4199d9354ba156244121d2aa7c0ad8293a06652275a47764ca2f46d52ea2dcfbd1e0c461211550e17096b606bc894148fb94639bba43209cf5f39ed2317f58092f4d56692cd031bd2a408c0fe571f7067c7afc0486a64e5327e1b91bf07af0e9ca309ce2c9b6ff09f0b2cea699a681d6e87fb4cd086853ff20f5ce1547e5ef88a5161dc6f802cafb6025e6600cf7b3359dc9c60da7c550ac47e8aa77dce9cf0f0abaaccb86068ba37c1c906b855ecf1b7fba61ac79d18138633750e7db2f72622289f7b5196d261bc4383494cd4d507ddbc1242b356ab0aebeddcce8ddbc918b13a0cb81e7f51dd48057217ba2ed205ede63acb9b6077c681ec6220a4614f7a5d01c6c103839f716acaea4bf5dcb2524aa5d73a99a11bb41d0eaa0d61403be065b5ac93660d1e6d2de03f96b7fb294ac904b06e66fba3ece9209964d71a9af489bf1519624cad23863ceee1c66ae77a026067df3de9b49b005ea3392e5d3f6745bcc821ecace6d16de954e5b4c81b0618d95e80ba7ca1e9b50ee5cbb805e5833a1426064bcc97f888cb70a79ae325767163baf235233267170e912ee1b9f08faf0039b6c49daa46b055355cb12954ee181f6572592945960e66fa956f360f28bdef3ece7e382f1508e9b9deeeb39c7e25661d95cda0a6f279142be3dc946525df6aa06b3c4ef431d1dcb55c3e71a03e362e8c35d543dce2ab3a95a94fc85120638d035d1251a5e5e4d66aca9b739d5092734d8ea0933959fef4677dac02cb12ac30807e08d114882fde200e373edd2d5d88ad524331384c78842ce7d44ae62eb24884a54f61b906fd8342d3fdbcc6882206a80f26395fcf989084129e4ac86b418a45918c69effccadd1c208ed05a271c32bf3284203d9a396373a2e295e2dbe9a6eab8b91dfbb04e0899e34089bcf1e168e549be38f65e01517f71043afb2491adda592e6adf4cd89663216b5f92e28ded63f8029434660114471904a0673fbb775e3d147b9fca0e40bd508400e9cde19d5afc7f3a1c2c2afd2a0bfdfbbfacca05cd7d060b29047e9f156a2b17cd26638a3731b46193b42c56579fdd7875f632afc20e3c20bc2ad24fcd90be060bfeb5baf516ff16d1b7d5732f4fa253a4366a028d27ad213002182ee35f5636f72aa02f2d6182e8b56fc7e580e7eb6c2a2dd384c61b71b7bb1ce11d6d98e2073238978c45760a5724b51ab7d1dcc2c1f2ff4a1a23d2182c475046b29f6fe1aee0e08e422517d8f7a8a5dabc672cba6f598aa42386581b2435f11b87590f46ec696ee1945f3915b0ffaf5c7d025fef33bc95204ecfd8b18195a5cbf494445d547c8cce3816b5a806f57916ccb8976cc8f0d2f77132d83b1bfc250e1afded23233d6977579db5ec74c25da955d113234fd345d1ae2741f8d954033ed2e80c2a216007dc8a68cf4c88c962a42b3c5035b62ff46effa4450e52ae286a2b8d41c0472ede0bccf13696a7f0dec46f016be550b9dbc93d19b4631bdbd7d7927ee9ea421082baa010496bafe8ca6256f8ad747378e7f45492e00e4507681cc5bc4b58e5d5181f52d469e95e8de2b5d82332f9dd54310df8128780d2ff0f5139e20cc368ae92dabc1dc6977c3a89a2656d4873aa5dbb3cfc321378ad781a9442c6e1f1b0a1a6df663cbf299eda84ec66df3757667d2bd53b7204e7ecb481c1d6a5674fc20f014e34833d7daa1cf1cafd18299c58fb9628be6e4856ad306315b8c8902b6906ff4c28e93b2cacc26140f0bcf68d3869f4c32fd39b195f2f54181b05fa8273fe7934dfc20c996f2226cab57b08be470f70941013523bc5ebf234b7a884c862a3e48a44f884a5441d96a0bd7ffb0877cc9f560d11895b6dcc4b4c34bf06ae0fbe247d2cc7fa52c2f0909e63a7516609b66f03fc7f97089c1ca937ddea24c95bf9d9d276e8bceb751b1dd02205d1c40120b1e22c26e5a4296b622e2b979255f19b8113b3100289355dacaffbfd0e64433c0898487dae654e4b1fbdc0d5393cff18f05b79259bf4273bb054011893a8f2a39f578c61afd23ef1ed4fe1237e8f1cd85f991ef18afe8239baa0f16abe7802666670d39a502081f83e410848c2f1cf80488ee5ef486e49366b9103b69eca6370b35c938af2f8adebb9999b4cc170f34931dc41c981cd9e37cdc94751bc542400c8673200684c2afc64ccc381f19d865f0adcdac2a18c3fa4393868f8f691be3d28b3fdf75c22bd5f68feeb62c42a9a8c6bb729e23c42cea358a611db06fc8ca41dbb4ebf03e4efe5a3161c95f8b52a96a7f1ba766068923163e505ee12a5ba72fb2038248f2cf82d02bd02fff2b695d3b3e29bc2b76068f921fc720df554014a855c0942675db09d7363dda35fac5c159248c3f7895e3300a939e1d938227b88cc06522ffe56f4a9ac15793539b2fdc75edcc44d5a55fc6ee70fee26f11e196c624a628cb3a3296a639a3561d167143c69ef2bb0601c06aa05137b01a04de4ddcf2f3f686b4238b932924d6c278bdb0dd33fd43833d415433bdcc4e9cbffe4bc27ee9028113bd6c8a4eeaeb8f8ead7f7849e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">密码：20010929</summary>
    
    
    
    <category term="Computer Networking" scheme="https://mashiro01.github.io/categories/Computer-Networking/"/>
    
    
    <category term="tcp/ip" scheme="https://mashiro01.github.io/tags/tcp-ip/"/>
    
    <category term="自顶向下" scheme="https://mashiro01.github.io/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 -- 应用层</title>
    <link href="https://mashiro01.github.io/2020/08/24/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://mashiro01.github.io/2020/08/24/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-08-24T06:20:18.000Z</published>
    <updated>2020-08-24T06:29:23.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络应用是计算机网络存在的理由，如果我们不能构想出任何有用的应用，也就没有任何必要去设计支持它们的网络协议了。</p></blockquote><h2><span id="ying-yong-ceng-xie-yi-yuan-li">应用层协议原理</span><a href="#ying-yong-ceng-xie-yi-yuan-li" class="header-anchor">#</a></h2><h3><span id="1-1-ying-yong-ceng-xie-yi">1.1 应用层协议</span><a href="#1-1-ying-yong-ceng-xie-yi" class="header-anchor">#</a></h3><p>应用层协议定义了运行在不同端系统上的应用程序如何相互交换报文</p><ul><li><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议</p></li><li><p>应用层的许多协议都是基于客户服务器方式</p></li></ul><p>同时特别的，应用层协议也定义了：</p><ul><li>交换的报文类型</li><li>各种报文类型的语法</li><li>字段的语义</li><li>确定一个进程何时以及如何发送报文，对报文进行相应的规则</li></ul><h3><span id="1-2-ying-yong-cheng-xu-ti-xi-jie-gou">1.2 应用程序体系结构</span><a href="#1-2-ying-yong-cheng-xu-ti-xi-jie-gou" class="header-anchor">#</a></h3><p>在对信息进行网络编码前，我们需要指定一份应用程序体系结构，来规定如何在端系统上组织该应用程序，这里介绍两种主流的结构：</p><ol><li><p>客户-服务器体系结构（CS）</p><ul><li>总有一台打开的主机，接受来自各方的请求，并将结果返回个用户</li><li>服务器的集合叫做数据中心</li></ul></li><li><p>P2P体系结构</p><ul><li>应用程序在间断连接的主机之间直接通信（对等方）</li><li>对中心服务器有最小的依赖</li><li>服务器一般用于追踪用户的ip地址，但报文在主机之间直接发送</li></ul></li></ol><h3><span id="1-3-jin-cheng-tong-xin">1.3 进程通信</span><a href="#1-3-jin-cheng-tong-xin" class="header-anchor">#</a></h3><ol><li><p>对于操作系统来说，进行通讯的并不是程序本身，而是<code>进程</code>，同时进程间交换的信息叫做<code>报文</code></p></li><li><p>对于网络应用程序来说，发起通信的一端叫做客户端，与之对应的另外一端称为服务端</p></li><li><p>进程通过一个称为<strong>套接字</strong>的软件接口来发送报文，其为应用层与运输层之间的接口，又称为<code>API</code></p></li><li><p>要向特定的地址发送信息，我们需要目的地的地址，这个一般使用<strong>IP</strong>进行标识。同时不同的应用有其自己所有的端口，来用于进行标识需要接收的内容</p></li></ol><h3><span id="1-4-bao-wen-chuan-shu">1.4 报文传输</span><a href="#1-4-bao-wen-chuan-shu" class="header-anchor">#</a></h3><p>为了得到合适于报文传输的运输层协议，我们需要从以下几点进行考虑</p><ol><li>可靠数据传输（确定信息容忍丢失的范围）</li><li>吞吐量（网络带宽的限制）</li><li>定时（信息传输需要的时间）</li><li>安全性</li></ol><p>这里先介绍两种常用的运输层协议：</p><ol><li><p>TCP (Transmission Control Protocol)</p><ul><li>面向连接的服务</li><li>可靠的数据传输服务</li><li>具有拥堵控制机制</li></ul></li><li><p>UDP (User Datagram Protocol)</p><ul><li>不可靠的数据传输服务</li><li>能以任意速率进行传输</li></ul></li></ol><p>因此在实际的运用过程中，我们要根据实际需求，来选择合适的传输方案</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;网络应用是计算机网络存在的理由，如果我们不能构想出任何有用的应用，也就没有任何必要去设计支持它们的网络协议了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span id=&quot;ying-yong-ceng-xie-yi-yuan-li&quot;&gt;应用层协议</summary>
      
    
    
    
    <category term="Computer Networking" scheme="https://mashiro01.github.io/categories/Computer-Networking/"/>
    
    
    <category term="自顶向下" scheme="https://mashiro01.github.io/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    
    <category term="网络层次" scheme="https://mashiro01.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 -- 传输层</title>
    <link href="https://mashiro01.github.io/2020/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://mashiro01.github.io/2020/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-08-24T05:14:05.000Z</published>
    <updated>2020-08-24T05:24:29.474Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#gai-shu-yu-yun-shu-ceng-fu-wu">概述与运输层服务</a><ul><li><a href="#1-1-yu-wang-luo-ceng-de-guan-xi">1.1 与网络层的关系</a></li><li><a href="#1-2-yin-te-wang-yun-shu-ceng-gai-shu">1.2 因特网运输层概述</a></li><li><a href="#1-3-duo-lu-fu-yong-yu-duo-lu-fen-jie">1.3 多路复用与多路分解</a></li></ul></li><li><a href="#wu-lian-jie-yun-shu-udp">无连接运输：UDP</a></li><li><a href="#ke-kao-shu-ju-chuan-shu-yuan-li">可靠数据传输原理</a><ul><li><a href="#gou-jian-ke-kao-shu-ju-chuan-shu-xie-yi">构建可靠数据传输协议</a></li><li><a href="#liu-shui-xia-ni-ke-kao-shu-ju-chuan-shu-xie-yi">流水下你可靠数据传输协议</a></li></ul></li><li><a href="#mian-xiang-lian-jie-de-yun-shu-tcp">面向连接的运输: TCP</a><ul><li><a href="#1-tcp-bao-wen-duan-jie-gou">1. TCP报文段结构</a></li><li><a href="#tcp-lian-jie-guan-li">TCP 连接管理</a></li></ul></li></ul><!-- tocstop --></div><p>运输层位于应用层与网络层之间，该层为运行在不同主机上的应用进程提供直接的通信服务起着重要作用。</p><h2><span id="gai-shu-yu-yun-shu-ceng-fu-wu">概述与运输层服务</span><a href="#gai-shu-yu-yun-shu-ceng-fu-wu" class="header-anchor">#</a></h2><p>运输层协议为运行在不同主机上的应用进程之间提供了<code>逻辑通信</code></p><blockquote><p>逻辑通信大体是指在<strong>不考虑</strong>中间的链路连接的情况下，运行不同进程的主机好像是直接通过一条管道连接起来</p></blockquote><p><img src="/images/Transport%20Layer/eg01.png" alt="conn"></p><p>和应用层协议相似，运输层协议仍是运行在<code>端系统</code>中，并将应用层传输的报文转换为<code>运输层报文段</code></p><p>那么从粗略的角度看，运输层报文是将报文划分为较小的块，并在其头部加上运输层首部组合而成的</p><h3><span id="1-1-yu-wang-luo-ceng-de-guan-xi">1.1 与网络层的关系</span><a href="#1-1-yu-wang-luo-ceng-de-guan-xi" class="header-anchor">#</a></h3><ul><li>网络层提供了<code>主机</code>之间的逻辑通信</li><li>运输层为运行在不同主机上的<code>进程</code>间提供了逻辑通信</li></ul><p>这里示例书上的一个例子：</p><p><img src="/images/Transport%20Layer/exp01.png" alt="mail trans"></p><p>翻译过来就是</p><blockquote><p>应用层报文 = 信封上的字符<br>进程 = 堂兄弟姐妹<br>主机 = 家庭<br>运输层协议 = 分发的邮递员<br>网络层协议 = 邮政服务</p></blockquote><p>同时我们需要注意的是，上层的服务往往受下层的服务所制约，而上层的协议能够提供特殊的服务（如TLS）</p><h3><span id="1-2-yin-te-wang-yun-shu-ceng-gai-shu">1.2 因特网运输层概述</span><a href="#1-2-yin-te-wang-yun-shu-ceng-gai-shu" class="header-anchor">#</a></h3><p>这里先提及下ip，ip是网络世界中主机的标识符，其位于网络层的服务之上</p><p>对于TCP和UDP服务来说，其最基本的责任就是将<code>端系统间ip的交付服务</code>扩展为<code>端系统上两个进程之间的交付服务</code></p><blockquote><p>扩展的过程称作是运输层的<code>多路复用与多路分解</code></p></blockquote><p>同时对于TCP和UDP来说，TCP为应用程序提供了几种附加服务</p><ol><li>可靠数据传输（数据不丢失）</li><li>拥塞控制（控制传输时的平衡）</li></ol><p>而UDP却是不可调节的，是一种不可靠的数据传输服务，能以任意速率发送数据</p><h3><span id="1-3-duo-lu-fu-yong-yu-duo-lu-fen-jie">1.3 多路复用与多路分解</span><a href="#1-3-duo-lu-fu-yong-yu-duo-lu-fen-jie" class="header-anchor">#</a></h3><p>对于一个进程来说，其有<code>一个或多个套接字</code>（每个套接字均有其专属的标识符），在数据传输层的过程中，运输层报文段并没有直接交付给进程，而是将数据交给了其中的套接字，由套接字向网络层分发</p><p><img src="/images/Transport%20Layer/02.png" alt="trans"></p><p>这时我们引出多路复用与多路分解的概念：</p><ul><li>将运输层报文段中的数据交付给正确的套接字的工作称为<strong>多路分解</strong></li><li>从不同的套接字里接收数据块，并生成报文段，再传递到网络层，这个工作成为<strong>多路复用</strong></li></ul><p>总结一下，多路复用和多路分解有以下的要求</p><ol><li>套接字有唯一标识符</li><li>报文段有特殊字段来指示所要交付到的套接字</li></ol><hr><p><img src="/images/Transport%20Layer/03.png" alt="trans"></p><blockquote><p>这是报文段的大体结构</p><p>端口号是长度为<code>16bit</code>的数，其中0-1023为<strong>周知端口号</strong>，用于内部特殊的服务，剩下的则可自由进行分配</p></blockquote><hr><p>在讨论完多路分解与多路复用的基本内容后，接下来我们来谈一谈不同协议的多路复用与多路分解</p><h2><span id="wu-lian-jie-yun-shu-udp">无连接运输：UDP</span><a href="#wu-lian-jie-yun-shu-udp" class="header-anchor">#</a></h2><blockquote><p>无连接传输：指在发送报文段前，发送方和接收方的运输层实体之间没有进行握手</p></blockquote><p>UDP 是 User Datagram Protocol 的简称， 中文名用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，UDP 在 IP 报文的协议号是 17</p><p><img src="/images/Transport%20Layer/UDP.png" alt="UDP"></p><p>这是基于UDP的报文段结构，可以看出作为一种最简洁的运输层协议，其除了复用/分解功能及少量的差错检测外，基本就没别的什么修饰了</p><p>UDP连接有如下特点：</p><ol><li>关于发送什么数据以及如何发送的应用层控制更为精细<ul><li>速度更快，延迟更低</li><li>在一定条件下，丢失的数据在能容忍的范围内</li><li>UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li><li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制</li></ul></li><li>无需建立连接<ul><li>不需要握手即可建立连接，即’发送即结束’</li><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul></li><li>无连接状态<ul><li>不需要维护连接时的诸如缓存之类的状态</li><li>支持多播，组播等</li></ul></li><li>分组首部开销小<ul><li>UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</li></ul></li></ol><h2><span id="ke-kao-shu-ju-chuan-shu-yuan-li">可靠数据传输原理</span><a href="#ke-kao-shu-ju-chuan-shu-yuan-li" class="header-anchor">#</a></h2><p>在讨论该如何实现可靠数据传输之前，先让我们明确下可靠数据传输的定义：</p><ul><li>即数据可以通过一条<strong>可靠的信道</strong>进行传输，在这一条信道之中，传输数据的比特不会受到损坏或丢失，而会按照发送顺序进行交付</li></ul><blockquote><p>这种形式上的传输很像无线传输时划分的信道，能使不同设备的通信得以划分，不会影响互相的通信</p></blockquote><p>这种所被提供的服务我们称为<code>可靠数据传输服务</code></p><p><img src="/images/Transport%20Layer/reliable_provide_service.png" alt="reli"></p><p>可以看出这种可信赖的传输通道是建立在传输层之上</p><p><img src="/images/Transport%20Layer/reliable_provide_imp.png" alt="reli"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Q：为什么可靠传输是建立在传输层上的A：作为逻辑上的传输，传输层的运输是不考虑真实的损失的，而在实际的传输中，建立在网络层上的ip服务在运输中是容易发生丢包现象的，所以要尽量保证逻辑上的交互成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3><span id="gou-jian-ke-kao-shu-ju-chuan-shu-xie-yi">构建可靠数据传输协议</span><a href="#gou-jian-ke-kao-shu-ju-chuan-shu-xie-yi" class="header-anchor">#</a></h3><p>在了解了可靠数据传输的基本信息之后，接下来让我们去了解如何去构建出可靠的数据传输</p><h4><span id="1-jing-wan-quan-ke-kao-xin-dao-de-ke-kao-shu-ju-chuan-shu-rdt-1-0">1. 经完全可靠信道的可靠数据传输: rdt_1.0</span><a href="#1-jing-wan-quan-ke-kao-xin-dao-de-ke-kao-shu-ju-chuan-shu-rdt-1-0" class="header-anchor">#</a></h4><p><img src="/images/Transport%20Layer/rdt1.png" alt="rdt"></p><blockquote><p>每个部分称为<strong>有限状态机</strong>(Finite-State-Machine)，简称<code>FSM</code></p></blockquote><p>在这一类别中，通过rdt_send()产生一个分组，通过rdt_recv()接收一个分组，这样就算拥有了一个完全可靠的信道</p><h4><span id="2-jing-ju-you-bi-te-chai-cuo-xin-dao-de-ke-kao-shu-ju-chuan-shu-rdt-2-0">2. 经具有比特差错信道的可靠数据传输: rdt_2.0</span><a href="#2-jing-ju-you-bi-te-chai-cuo-xin-dao-de-ke-kao-shu-ju-chuan-shu-rdt-2-0" class="header-anchor">#</a></h4><p>在由rdt1.0建立了可靠的运输层传输模型后，接下来我们来看下分组中比特更容易受损的底层信道</p><blockquote><p>现在先假定所有的分组是按顺序所发送的</p></blockquote><p>对于接收一条信息，我们可能有<code>肯定确认</code>或者<code>否定确认</code>两种状态，前者即是<strong>OK</strong>状态，而后者却是受到了损失，需要重新确认</p><p>而这种因错误而需重传的协议在计算机中称为是<code>自动重传协议</code>(ARQ)</p><p>ARQ协议规定了需要另外三种协议功能来处理存在比特差错的情况：</p><ol><li>差错检测<ul><li>即数据包具有额外的比特来进行差错校验，汇集在协议规定的分组检验和字段中</li></ul></li><li>接收方反馈<ul><li>对于肯定确认(ACK)和否定确认(NAK)两种状态，我们需要用<code>1bit</code>的<code>0或1</code>来进行反馈</li></ul></li><li>重传</li></ol><p><img src="/images/Transport%20Layer/rdt2.png" alt="rdt"></p><p>对于发送端：</p><ol><li>先等待上层的调用，待rdt_send()发生后，经下层udt_send()发送分组</li><li>等待反馈（网络IO阻塞状态）</li><li>根据反馈进行下一次发送的准备<ul><li>ACK则准备下一个分组的发送</li><li>NAK则进行重传</li></ul></li><li>完成循环</li></ol><p>对于接收端：</p><ol><li>rdt_rev()接收数据</li><li>根据校验结果返回对应的状态位</li></ol><p>以上就是在理想条件下rdt2.0所发挥的作用了，那么如果状态位发生损坏了呢？</p><h4><span id="3-rdt2-0-de-xiu-ding-ban-rdt2-1">3. rdt2.0的修订版: rdt2.1</span><a href="#3-rdt2-0-de-xiu-ding-ban-rdt2-1" class="header-anchor">#</a></h4><p><img src="/images/Transport%20Layer/rdt2.1.png" alt="rdt"></p><p>对于这种情况，这里引入了<code>序号</code>(SEQ)的概念，即我们只需要检查包的序号即可判断<br>其是否为重传</p><p>对于rdt2.0所规定的<code>等停协议</code>来说，两个序列号(0, 1)已经足够使用</p><p>这里解释下具体的过程</p><p>一. 发送方获得来自上层的数据后，封包（编号为0）发送至接收方，接收方接收到分组后:</p><ol><li>如果没有损坏，回送ACK分组，并等待编号为1的分组</li><li>如果损坏，回送NAK分组，并继续等待编号为0的分组</li></ol><p>二. 发送方接收到回送分组后:</p><ol><li>如果没有损坏，且为ACK分组，无任何动作，等待上层协议</li><li>如果没有损坏，且为NAK分组，重发编号为0的分组</li><li>如果损坏，无论是ACK还是NAK，重发编号为0的分组</li></ol><p>三. 接收方收到分组后(接收方不知道自己的ACK或NAK分组在传输过程中是否损坏):</p><ol><li>如果没有损坏，且为编号1的分组，回送ACK分组，且等待编号为0分组（循环）</li><li>如果没有损坏，且为编号0的分组，回送ACK分组，且等待编号为1分组</li><li>如果损坏，回送NAK分组，等待编号为0分组</li></ol><h4><span id="4-rdt2-1-de-xiu-ding-ban-rdt2-2">4. rdt2.1的修订版: rdt2.2</span><a href="#4-rdt2-1-de-xiu-ding-ban-rdt2-2" class="header-anchor">#</a></h4><p>作为继承了rdt2.1大部分特性的版本，这里我们直接来讨论其所更新的内容</p><p><img src="/images/Transport%20Layer/rdt2.20.png" alt="rdt"><br><img src="/images/Transport%20Layer/rdt2.21.png" alt="rdt"></p><p>rdt2.2与2.1的区别就在于去掉了NAK，而在ACK分组中显式指出分组编号</p><p>一. 发送方获得来自上层的数据后，封包（编号为0）发送至接收方，接收方接收到分组后:</p><ol><li>如果没有损坏，回送ACK0分组，并等待编号为1的分组</li><li>如果损坏，回送ACK1分组，并继续等待编号为0的分组</li></ol><p>二. 发送方接收到回送分组后:</p><ol><li>如果没有损坏，且为ACK0分组，无任何动作，等待上层协议</li><li>如果没有损坏，且为ACK1分组，重发编号为0的分组</li><li>如果损坏，无论是ACK1还是ACK0，重发编号为0的分组</li></ol><p>三. 接收方收到分组后(接收方不知道自己的ACK分组在传输过程中是否损坏):</p><ol><li>如果没有损坏，且为编号1的分组，回送ACK1分组，且等待编号为0分组（循环）</li><li>如果没有损坏，且为编号0的分组，回送ACK0分组，且等待编号为1分组</li><li>如果损坏，回送ACK1分组，等待编号为0分组</li></ol><h4><span id="5-jing-ju-you-bi-te-chai-cuo-de-diu-bao-xin-dao-de-ke-kao-shu-ju-chuan-shu-rdt3-0">5. 经具有比特差错的丢包信道的可靠数据传输: rdt3.0</span><a href="#5-jing-ju-you-bi-te-chai-cuo-de-diu-bao-xin-dao-de-ke-kao-shu-ju-chuan-shu-rdt3-0" class="header-anchor">#</a></h4><p>在解决了包受损的情况后，这时如果在传输过程中发生了<code>丢包</code>该如何去解决呢？</p><p><img src="/images/Transport%20Layer/rdt3.png" alt="rdt"></p><p>这里引入了<code>倒计时定时器</code>的概念: 规定时间内，若无反馈，则重传</p><p>第一种：过程中未丢包，但是数据比特出错或者不符合序号，和我们讨论过的 rdt2.2 差不多，那么此时就没有任何动作，毫无作为就好了，等到时间间隔一到，当做超时处理，重发数据。</p><p>第二种：是真正的丢包了，所以时间一到，重新发送。</p><p>第三种最理想：啥事没有，一切正常，跳到下一个状态，等待发送下一个包</p><p><img src="/images/Transport%20Layer/rdt3_bit.png" alt="rdt"></p><h3><span id="liu-shui-xia-ni-ke-kao-shu-ju-chuan-shu-xie-yi">流水下你可靠数据传输协议</span><a href="#liu-shui-xia-ni-ke-kao-shu-ju-chuan-shu-xie-yi" class="header-anchor">#</a></h3><p>在理想状态下，rdt3.0已经解决了可靠数据传输的问题，但是由于加上了过多了检测信息，其<code>IO阻塞型的等停协议</code>对其性能造成了不小的阻碍</p><p>这时我们引入了<code>流水线</code>的概念来对分组进行传输(类似于异步传输，IO不阻塞类型)，即<code>允许发送多个分组而无需等待确认</code></p><p><img src="/images/Transport%20Layer/pipeline.png" alt="pipeline"></p><p>在引入了流水线的概念后</p><ul><li>需增加序号的范围来为每个分组确定一个序号</li><li>双方要建立完善的缓存机制来处理分组</li><li>对错误进行进一步处理，这里有两种方式：<code>回退N步</code>和<code>选择重传</code></li></ul><h4><span id="hui-tui-n-bu-gbn">回退N步（GBN）</span><a href="#hui-tui-n-bu-gbn" class="header-anchor">#</a></h4><p>这个协议又称为<code>滑动窗口协议</code>，引入了窗口的概念</p><p><img src="/images/Transport%20Layer/send.png" alt="win"></p><p>这里发送方数据有四种状态：</p><ol><li>已被确认：指已发送又被接收端成功确认的数据</li><li>发送但未被确认：已发送但还未被接收端确认，未接收到接收端的ACK，仍属于窗口内的内容</li><li>可用但未发送：已经可以进行发送但是还未发送的信息</li><li>不可用：超出了接收范围的部分</li></ol><p>接收方数据的状态：</p><ol><li>Received and ACK Not Send to Process: 已接受也已经回复ACK，但是未向应用层多路分解，仍在缓存中</li><li>Received Not ACK: 已经接收并，但是还没有回复ACK，这些包可能输属于Delay ACK的范畴了</li><li>Not Received: 有空位，还没有被接收的数据</li></ol><p>对于窗口的大小，这时接收方和发送方<code>协商</code>得出的结果。对于超出的部分可以留到下一层整体发送的时候再发送</p><p>GBN发送方必须响应三种类型的事件：</p><ol><li>上层的调用<ul><li>调用rdt_send()时需判断是否能进入当前窗口，不可则进入缓存</li><li>或者使用同步机制控制rdt_send的使用</li></ul></li><li>收到一个ACK<ul><li>累积确认的计数</li></ul></li><li>超时事件</li></ol><p>同时gbn接收方在遇到乱序的分组时，并不是加入缓存，而是直接丢弃，等待发送方超时重传</p><p><img src="/images/Transport%20Layer/gbn.png" alt="gbn"></p><h4><span id="xuan-ze-chong-chuan">选择重传</span><a href="#xuan-ze-chong-chuan" class="header-anchor">#</a></h4><p>显然对于GBN来说其已经解决了大部分可靠传输时的问题，但是在最后一点讨论GBN的错误处理时，还是能看到如果错了一个，将会有大量的分组进行重传</p><p><img src="/images/Transport%20Layer/sr.png" alt="sr"></p><p><code>选择重传协议</code>(SR)</p><ol><li>仅仅直接重发那些丢失或者受损的分组</li><li>对于正确接收但是顺序错误的，进入缓存，直到正确的序号为止（不返回ACK）</li></ol><p><img src="/images/Transport%20Layer/ssr.png" alt="SR"></p><h2><span id="mian-xiang-lian-jie-de-yun-shu-tcp">面向连接的运输: TCP</span><a href="#mian-xiang-lian-jie-de-yun-shu-tcp" class="header-anchor">#</a></h2><p>TCP连接是<strong>面向连接的</strong>，在之间了解rdt时候就已经规定了诸如ACK之类的标志，而TCP连接进行的<code>握手</code>正是利用了这些标志</p><p>TCP连接同其他可靠连接一样是<code>点对点</code>的，同时属于全双工服务</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 这种tcp连接建立的过程称为是三次握手clientSocket.connect((serverName, serverPort))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/Transport%20Layer/tcp01.png" alt="tcp"></p><p>tcp连接具有自己的缓存(相当于滑动窗口的存在)，同时具有<code>最大报文长度</code>(MSS)来对报文的长度进行限制</p><blockquote><p>在链路层中有最大长度限制 — 最大传输单元(MTU)，一般MTU的大小为<strong>1500</strong>，MTU = MSS + TCP首部长度 + IP首部长度</p></blockquote><h3><span id="1-tcp-bao-wen-duan-jie-gou">1. TCP报文段结构</span><a href="#1-tcp-bao-wen-duan-jie-gou" class="header-anchor">#</a></h3><p><img src="/images/Transport%20Layer/tcp02.png" alt="tcp"></p><h4><span id="xu-hao-he-que-ren-hao">序号和确认号</span><a href="#xu-hao-he-que-ren-hao" class="header-anchor">#</a></h4><p>TCP把数据看作是<code>无结构的，有序的</code>字节流，因此一个报文段的序号是该报文段<code>首字节</code>的字节流编号</p><ul><li><p>字节序号<br>TCP 连接中，为传送的字节流（数据）中的每一个字节按顺序编号。也就是说，在<code>一次 TCP 连接建立的开始，到 TCP 连接的断开</code>，你要传输的所有数据的<code>每一个字节</code>都要编号。这个序号称为字节序号</p></li><li><p>初始序号 ISN<br>当新连接建立的时候，<code>第一个字节</code>数据的序号称为 ISN(Initial Sequence Number)，即初始序号。ISN 一开始并不一定就是 1。在 RFC (规定网络协议的文档)中规定，ISN 的分配是根据时间来的。当操作系统初始化的时候，有一个全局变量假设为 g_number 被初始化为 1（或 0），然后每隔 4us 加 1. 当 g_number 达到最大值的时候又绕回到 0.当新连接建立时，就把 g_number 的值赋值给 ISN</p></li><li><p>报文段序号<br>如果一个 TCP 报文段的序号为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文段携带的第一个字节序号是 301，最后一个字节序号是 400.</p></li></ul><p><img src="/images/Transport%20Layer/tcp_num.png" alt="tcp"></p><p>而对于确认号来说，<code>A填进报文段的确认号是主机A期望从主机B收到的下一字节的序号</code></p><h3><span id="tcp-lian-jie-guan-li">TCP 连接管理</span><a href="#tcp-lian-jie-guan-li" class="header-anchor">#</a></h3><p>要建立TCP连接要经历以下三个步骤（<code>三次握手</code>）：</p><ol><li>先向服务器端发送一个特殊的报文段，此报文段<code>SYN</code>位(握手信号)为1，因此又称为SYN报文段，同时用ISN将seq赋值</li><li>当服务器接收到此报文段后，为该TCP连接分配缓存，同时返回的数据报中SYN为1，seq为服务器端生成，确认号为seq+1</li><li>客户端在接收到后也要为连接分配缓存，seq与ack同步，同时确认号加1，准备进入数据接收状态</li></ol><p><img src="/images/Transport%20Layer/three.png" alt="tcp"></p><p>要结束连接要经历以下四个步骤（<code>四次挥手</code>）</p><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态</li></ol><p><img src="/images/Transport%20Layer/four.png" alt="tcp"></p><p><img src="/images/Transport%20Layer/tcp_lifeline.png" alt="tcp"></p><!-- 剩下的拥塞控制及其解决方法请自行看书，太过于理论化了 -->]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#gai-shu-yu-yun-shu-ceng-fu-wu&quot;&gt;概述与运输层服务&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-yu-wang-luo-ceng-de-gua</summary>
      
    
    
    
    <category term="Computer Networking" scheme="https://mashiro01.github.io/categories/Computer-Networking/"/>
    
    
    <category term="自顶向下" scheme="https://mashiro01.github.io/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    
    <category term="网络层次" scheme="https://mashiro01.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++：返回引用，指针还是值</title>
    <link href="https://mashiro01.github.io/2020/08/24/C-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%80%BC/"/>
    <id>https://mashiro01.github.io/2020/08/24/C-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%80%BC/</id>
    <published>2020-08-24T00:09:20.000Z</published>
    <updated>2020-08-24T05:24:53.687Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fan-hui-zhi">返回值</a></li><li><a href="#fan-hui-zhi-zhen">返回指针</a></li><li><a href="#fan-hui-zhi-you-hua">返回值优化</a><ul><li><a href="#pu-tong-yin-yong">普通引用</a></li><li><a href="#const-yin-yong">const引用</a></li><li><a href="#you-zhi-yin-yong">右值引用</a></li></ul></li><li><a href="#can-kao-lian-jie">参考链接</a></li></ul><!-- tocstop --></div><p>自c语言中的指针以来，内存的管理与使用一直是程序员的痛处。不恰当的指针使用常常会导致严重的内存错误，而随意地返回安全的对象和值却间接地导致了程序运行效率地下降</p><p>在C++中引入了引用(Reference)来化解指针所带来的难题，但是这也是建立在正确使用的基础之上的</p><blockquote><p>引用在C++中可以看作是自解引用的指针，两者的性质相同，在汇编代码上并无异处</p></blockquote><h2><span id="fan-hui-zhi">返回值</span><a href="#fan-hui-zhi" class="header-anchor">#</a></h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;func() &#123;    int a &#x3D; 1;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于这个函数，可以看出我们的本意是想返回a的引用值，但是对于函数来是，其是动态生成的，在完成调用后其中的局部变量值就会在栈中被销毁，无法形成长久的引用关系，一般在编译的时候就会为我们抛出这样一个警告：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">main.cc:4:10: warning: reference to stack memory associated with local variable &#39;a&#39; returned [-Wreturn-stack-address]  return a;         ^1 warning generated.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以得到这样一个结论</p><blockquote><p>当返回局部变量时我们一定要返回值，同时较小的结构也可以用过值来进行返回</p></blockquote><h2><span id="fan-hui-zhi-zhen">返回指针</span><a href="#fan-hui-zhi-zhen" class="header-anchor">#</a></h2><p>指针在C中是常用的一种返回手段，能直接返回结构对应的地址</p><p>但是在C++中除了数组之外，一般直接用引用来替代指针的作用</p><h2><span id="fan-hui-zhi-you-hua">返回值优化</span><a href="#fan-hui-zhi-you-hua" class="header-anchor">#</a></h2><blockquote><p>既然对于值我们可以任意返回而不易出错，问什么我们还要设计出返回指针或者是引用的形式呢?</p></blockquote><p>这里给出一个相对于普通变量来说更大的结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct Foo &#123;  int i;  &#x2F;&#x2F; 假设这里有许许多多你看不见的属性&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当我们调用这样一个函数时，其可返回类型为Foo的值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Foo f() &#123;    Foo a;    a.i &#x3D; 101;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于Foo很大，当我们使用f()的返回值，比如Foo foo = f();的时候，按照常理，f()的返回值会被赋予foo，这个过程可能会发生拷贝，导致性能下降。这时对返回结果进行优化就显得尤为重要</p><h3><span id="pu-tong-yin-yong">普通引用</span><a href="#pu-tong-yin-yong" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string &amp;func(const string &amp;s1, const string &amp;s2) &#123;    return s1 + s2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于引用来说其在调用或返回时不会再用一个新值来对原先的值进行拷贝，而是直接使用原先的值进行操作，并在返回时直接返回内存中这个值的引用，并不会发生拷贝，从而一定程度上提升了程序的性能</p><p>同时需要需要了解的是这种引用称为是左值引用</p><blockquote><p>所谓左值一般可以认为是变量，是能够随意被赋值并使用的值，也是只能放在等号左边的值</p></blockquote><p>因此对于一个非局部变量的值，我们可以使用引用来对其进行返回</p><h3><span id="const-yin-yong">const引用</span><a href="#const-yin-yong" class="header-anchor">#</a></h3><p>使用引用固然能在函数返回时提高程序的性能，但是如果我们想要返回一个较大结构的临时变量呢?是不是只能返回值呢?</p><p>显然结果并不是这样的，我们可以使用const关键字对引用进行修饰从而延长被引用对象的生命周期，比如使用<code>const Foo &amp;foo = f()</code>就是正确的</p><blockquote><p>Only local const references prolong the lifespan</p></blockquote><p>这里引用下大佬博客上总结的两点</p><ol><li>引用必须是静态的，也就是必须用const来修饰这个引用。这是因为函数的返回值属于右值，也就是（rvalue）。普通的引用是左值引用，也就是lvalue reference。左值引用不能指向右值引用，只有const的左值引用才能用来指向右值</li><li>本来f()的返回值是一个临时的变量，在它调用结束后，就应该销毁了。可是通过像这样const Foo&amp; foo = f();，把临时的返回值赋值给一个const左值引用，f()返回值并不会立即销毁。这等于是在const引用的作用域内，延长了f()返回值的存活时间</li></ol><blockquote><p>所谓右值就是等号右边的值，一般为函数的返回值或者是明确的数值，右值只能在等号右边，并不能作为左值并被赋值</p></blockquote><h3><span id="you-zhi-yin-yong">右值引用</span><a href="#you-zhi-yin-yong" class="header-anchor">#</a></h3><p>右值引用是C++11中新加入的内容，是一个尤为重要的概念，其主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能</p><p>相比于<code>&amp;</code>是对左值进行绑定，<code>&amp;&amp;</code>就是对右值进行一个绑定，我们可以这样完成绑定</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 左值引用int i &#x3D; 100;int &amp;a &#x3D; i;&#x2F;&#x2F; 右值引用int &amp;&amp;b &#x3D; 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>右值可以看作是一种特殊的匿名变量，通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</p><p>同时右值引用可以看作是加了const的左值引用，其自身是一个左值，能够被任意修改，而其本质却是临时变量的右值，所以左值引用可以指向一个右值引用，而右值引用去不能被另外一个右值引用所指向</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;&amp;i &#x3D; 100;&#x2F;&#x2F; 正确做法i++;int tmp &#x3D; 200; i &#x3D; tmp;int &amp;left &#x3D; i;&#x2F;&#x2F; 错误做法int &amp;&amp;j &#x3D; 200;j &#x3D; i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="can-kao-lian-jie">参考链接</span><a href="#can-kao-lian-jie" class="header-anchor">#</a></h2><p><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a><br><a href="https://marvinsblog.net/post/2018-08-07-cplusplus-return-value-or-reference/">C++：关于函数返回的一件小事——是返回值还是返回引用？</a><br><a href="https://stackoverflow.com/questions/2784262/does-a-const-reference-class-member-prolong-the-life-of-a-temporary">Does a const reference class member prolong the life of a temporary?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#fan-hui-zhi&quot;&gt;返回值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#fan-hui-zhi-zhen&quot;&gt;返回指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#fan</summary>
      
    
    
    
    <category term="c/c++" scheme="https://mashiro01.github.io/categories/c-c/"/>
    
    
    <category term="返回值的优化" scheme="https://mashiro01.github.io/tags/%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>WSL2下kernel header的安装</title>
    <link href="https://mashiro01.github.io/2020/08/24/wsl2%E4%B8%8B%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>https://mashiro01.github.io/2020/08/24/wsl2%E4%B8%8B%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-24T00:01:08.000Z</published>
    <updated>2020-08-24T05:24:43.942Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a></li><li><a href="#cao-zuo">操作</a></li></ul><!-- tocstop --></div><h2><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h2><p>本来正常的linux发行版只要安装<code>linux-headers-$(uname -r)</code>就能装上内核头文件，但wsl2作为一个不一般的linux发行版，并没有直接给出安装包，要手动安装才能正常使用</p><h2><span id="cao-zuo">操作</span><a href="#cao-zuo" class="header-anchor">#</a></h2><p>先去github上找到对应版本的内核源码，我这里使用的是<code>4.19.121-microsoft-standard</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base)  ⚡ root@404-NOT-FOUND  ~&#x2F;forExtract&#x2F;kernel  uname -r4.19.121-microsoft-standard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那我就应该下载这个版本: <a href="https://github.com/microsoft/WSL2-Linux-Kernel/releases/tag/4.19.121-microsoft-standard">https://github.com/microsoft/WSL2-Linux-Kernel/releases/tag/4.19.121-microsoft-standard</a></p><ul><li><p>安装依赖</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt install libelf-dev build-essential pkg-configapt install bison build-essential flex libssl-dev libelf-dev bc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zvxf 4.19.121-microsoft-standard.tar.gzcd WSL2-Linux-Kernel-4.19.121-microsoft-standard.tar.gzzcat &#x2F;proc&#x2F;config.gz &gt; .configmake -j $(nproc)               &#x2F;&#x2F;Compile the kernel and modulesmake -j $(nproc) modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>编译完成后创建软链接即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln ~&#x2F;kernel&#x2F;WSL2-Linux-Kernel-4.19.121-microsoft-standard &#x2F;usr&#x2F;src&#x2F;linux-headers-4.19.121-microsoft-standard&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qian-yan&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cao-zuo&quot;&gt;操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;/div&gt;

&lt;</summary>
      
    
    
    
    <category term="wsl2调教" scheme="https://mashiro01.github.io/categories/wsl2%E8%B0%83%E6%95%99/"/>
    
    
    <category term="kernel" scheme="https://mashiro01.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>初探内核模块</title>
    <link href="https://mashiro01.github.io/2020/08/24/%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2/"/>
    <id>https://mashiro01.github.io/2020/08/24/%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2/</id>
    <published>2020-08-23T16:29:17.000Z</published>
    <updated>2020-08-24T05:24:40.121Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a></li><li><a href="#shi-xian">实现</a></li><li><a href="#yun-xing">运行</a></li></ul><!-- tocstop --></div><h2><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h2><p>正好今天开始开始看《Linux内核设计与实现》这本书，就以Hello,world开个头吧</p><h2><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 模块所需头文件#include &lt;linux&#x2F;init.h&gt;#include &lt;linux&#x2F;module.h&gt;#include &lt;linux&#x2F;kernel.h&gt;#include &lt;linux&#x2F;moduleparam.h&gt;&#x2F;&#x2F; 许可证书MODULE_LICENSE(&quot;GPL&quot;);static int __init mod_init(void) &#123;    printk(KERN_ALERT &quot;Hello, World\n&quot;);    return 0;&#125;static void __exit mod_exit(void) &#123;    printk(KERN_ALERT &quot;Goodbye\n&quot;);&#125;module_init(mod_init);module_exit(mod_exit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-m :&#x3D; hello.oCURRENT_PATH :&#x3D; $(shell pwd)VERSION_NUM :&#x3D; $(shell uname -r)LINUX_PATH :&#x3D; &#x2F;usr&#x2F;src&#x2F;linux-headers-$(VERSION_NUM)all:make -C $(LINUX_PATH) M&#x3D;$(CURRENT_PATH) modulesclean:make -C $(LINUX_PATH) M&#x3D;$(CURRENT_PATH) clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到的是内核模块的输出与标准输出有稍许不同的地方：</p><ul><li><code>printk</code>中<code>KERN_*</code>代表了优先级，与输出内容隔一个空格</li><li><code>printf</code>就是标准输出，只是调用系统函数输出字符串</li></ul><h2><span id="yun-xing">运行</span><a href="#yun-xing" class="header-anchor">#</a></h2><p>直接make得到一大串文件</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.├── Makefile├── Module.symvers├── hello.c├── hello.ko├── hello.mod.c├── hello.mod.o├── hello.o└── modules.order<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里输出的.o文件并不能直接运行，为REL类型</p></blockquote><p><code>*.ko</code>即为我们所需的内核模块，<code>insmod $&#123;name&#125;.ko</code>将模块加载进内核</p><p>用dmesg查看输出</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">[46478.783149] WSL2: Performing memory compaction.[46539.789768] WSL2: Performing memory compaction.[46660.796831] WSL2: Performing memory compaction.[46781.803469] WSL2: Performing memory compaction.[46902.810284] WSL2: Performing memory compaction.[46963.817192] WSL2: Performing memory compaction.[47007.007476] Hello, World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>rmmod $(name)</code>退出该模块</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">[53723.654584] WSL2: Performing memory compaction.[53784.665033] WSL2: Performing memory compaction.[53845.672471] WSL2: Performing memory compaction.[53906.679157] WSL2: Performing memory compaction.[54027.685937] WSL2: Performing memory compaction.[54054.799471] Goodbye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qian-yan&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#shi-xian&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#yun-xing&quot;&gt;运行&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="linux kernel" scheme="https://mashiro01.github.io/categories/linux-kernel/"/>
    
    
    <category term="kernel" scheme="https://mashiro01.github.io/tags/kernel/"/>
    
    <category term="module" scheme="https://mashiro01.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>c/c++判断溢出</title>
    <link href="https://mashiro01.github.io/2020/08/23/c%E5%88%A4%E6%96%AD%E6%BA%A2%E5%87%BA/"/>
    <id>https://mashiro01.github.io/2020/08/23/c%E5%88%A4%E6%96%AD%E6%BA%A2%E5%87%BA/</id>
    <published>2020-08-23T15:51:26.000Z</published>
    <updated>2020-08-24T05:24:35.710Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int isAddOverflow(int a, int b) &#123;    int c &#x3D; 0;    __asm &#123;        mov eax, a        add eax, b        jo overflowed        xor eax, eax        jmp no_overflowed    overflowed:        mov eax, 1        mov c, eax    no_overflowed:    &#125;    return c;&#125;int main() &#123;    cout &lt;&lt; isAddOverflow(0x7fffffff, 1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用汇编判读OF标志位是否变化即可得到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;/div&gt;

&lt;pre class=&quot;line-numbers language-cpp&quot; data-language=&quot;cpp&quot;&gt;&lt;code class=&quot;language-cp</summary>
      
    
    
    
    <category term="c/c++" scheme="https://mashiro01.github.io/categories/c-c/"/>
    
    
    <category term="溢出判断" scheme="https://mashiro01.github.io/tags/%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mashiro01.github.io/2020/08/23/hello-world/"/>
    <id>https://mashiro01.github.io/2020/08/23/hello-world/</id>
    <published>2020-08-23T15:32:04.288Z</published>
    <updated>2020-08-23T15:32:04.288Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span><a href="#quick-start" class="header-anchor">#</a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="#create-a-new-post" class="header-anchor">#</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span><a href="#run-server" class="header-anchor">#</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span><a href="#generate-static-files" class="header-anchor">#</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="#deploy-to-remote-sites" class="header-anchor">#</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
