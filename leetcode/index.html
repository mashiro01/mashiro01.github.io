<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>leetcode · Mashiroの小站</title><meta name="description" content="1. 两数之和
9. 回文数
13. 罗马数字转整数
14. 最长公共前缀
20. 有效的括号
21. 合并两个有序链表
26. 删除排序数组中的重复项
35. 搜索插入位置
58. 最后一个单词的长度
66. 加一
83. 删除排序链表中的重复元素
100. 相同的树
101. 对称二叉树
118"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.1.1"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Typography</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">Sakamoto</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/categories/index.html">categories</a></li><li><a href="/leetcode/index.html" class="current">leetcode</a></li><li><a href="/tags/index.html">tags</a></li><li><a href="/writeup/SUCTF_2018.html">writeup</a></li><li><a href="/writeup/SUCTF_2019.html">writeup</a></li><li><a href="/writeup/index.html">writeup</a></li><li><a href="/writeup/MRCTF_2020.html">writeup</a></li><li class="soc"><a href="https://github.com/mashiro01" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://mashiro01.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="https://mashiro01.github.io" rel="noopener noreferrer">Mashiroi</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>leetcode</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2020-08-24</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/leetcode/index.html#comments">评论</a></span></p><p class="post-abstract"><div class="toc">

<!-- toc -->
<ul>
<li><a href="#1-liang-shu-zhi-he">1. 两数之和</a></li>
<li><a href="#9-hui-wen-shu">9. 回文数</a></li>
<li><a href="#13-luo-ma-shu-zi-zhuan-zheng-shu">13. 罗马数字转整数</a></li>
<li><a href="#14-zui-chang-gong-gong-qian-zhui">14. 最长公共前缀</a></li>
<li><a href="#20-you-xiao-de-gua-hao">20. 有效的括号</a></li>
<li><a href="#21-he-bing-liang-ge-you-xu-lian-biao">21. 合并两个有序链表</a></li>
<li><a href="#26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang">26. 删除排序数组中的重复项</a></li>
<li><a href="#35-sou-suo-cha-ru-wei-zhi">35. 搜索插入位置</a></li>
<li><a href="#58-zui-hou-yi-ge-dan-ci-de-chang-du">58. 最后一个单词的长度</a></li>
<li><a href="#66-jia-yi">66. 加一</a></li>
<li><a href="#83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su">83. 删除排序链表中的重复元素</a></li>
<li><a href="#100-xiang-tong-de-shu">100. 相同的树</a></li>
<li><a href="#101-dui-cheng-er-cha-shu">101. 对称二叉树</a></li>
<li><a href="#118-yang-hui-san-jiao">118. 杨辉三角</a></li>
<li><a href="#459-chong-fu-de-zi-zi-fu-chuan">459. 重复的子字符串</a></li>
<li><a href="#1480-yi-wei-shu-zu-de-dong-tai-he">1480. 一维数组的动态和</a></li>
</ul>
<!-- tocstop -->
</div>

<h2><span id="1-liang-shu-zhi-he">1. 两数之和</span><a href="#1-liang-shu-zhi-he" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：12 ms
内存消耗：8.3 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;num, int target) &#123;
    unordered_map&lt;int, int&gt; numMap;

    int i &#x3D; 0;
    for (; i &lt; num.size(); i++) &#123;
        numMap[num[i]] &#x3D; i;
    &#125;

    for (i &#x3D; 0; i &lt; num.size(); i++) &#123;
        if (numMap.find(target - num[i]) !&#x3D; numMap.end() &amp;&amp; numMap[target - num[i]] !&#x3D; i) &#123;
            return &#123;i, numMap[target - num[i]]&#125;;
        &#125;
    &#125;

    return &#123;&#125;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="9-hui-wen-shu">9. 回文数</span><a href="#9-hui-wen-shu" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：12 ms
内存消耗：6.1 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isPalindrome(int x) &#123;
        if (x &lt; 0) &#123;
            return false;
        &#125; else &#123;
            std::string a &#x3D; std::to_string(x);

            int i &#x3D; 0,j &#x3D; a.size() - 1;

            while (i &lt; j) &#123;
                if (a[i++] !&#x3D; a[j--]) &#123;
                    return false;
                &#125;
            &#125;

            return true;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="13-luo-ma-shu-zi-zhuan-zheng-shu">13. 罗马数字转整数</span><a href="#13-luo-ma-shu-zi-zhuan-zheng-shu" class="header-anchor">#</a></h2><p><code>这题回来要优化</code></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：40 ms
内存消耗：7.9 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int romanToInt(string s) &#123;
    unordered_map&lt;char, int&gt; roma &#x3D; &#123;
        &#123;&#39;I&#39;, 1&#125;, &#123;&#39;V&#39;, 5&#125;, &#123;&#39;X&#39;, 10&#125;,
        &#123;&#39;L&#39;, 50&#125;, &#123;&#39;C&#39;, 100&#125;, &#123;&#39;D&#39;, 500&#125;, &#123;&#39;M&#39;, 1000&#125;
    &#125;;

    int ans &#x3D; 0;

    int i;
    for (i &#x3D; s.size() - 1; i &gt;&#x3D; 1; i--) &#123;
        if (roma[s[i]] &gt; roma[s[i - 1]]) &#123;
            ans +&#x3D; roma[s[i]] - roma[s[i - 1]];
            i--;
        &#125; else &#123;
            ans +&#x3D; roma[s[i]];
        &#125;
    &#125;

    if (i &#x3D;&#x3D; 0) ans +&#x3D; roma[s[0]];

    return ans;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="14-zui-chang-gong-gong-qian-zhui">14. 最长公共前缀</span><a href="#14-zui-chang-gong-gong-qian-zhui" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：0 ms
内存消耗：6.7 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;
    string res &#x3D; &quot;&quot;;

    if (strs.empty()) return res;

    for (int j &#x3D; 0; j &lt; strs[0].length(); j++) &#123;
        for (int i &#x3D; 1; i &lt; strs.size(); i++) &#123;
            if (strs[i][j] !&#x3D; strs[i - 1][j] || j &gt; strs[i - 1].size() || j &gt; strs[i].size()) &#123;
                return res;
            &#125;
        &#125;

        res.push_back(strs[0][j]);
    &#125;

    return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="20-you-xiao-de-gua-hao">20. 有效的括号</span><a href="#20-you-xiao-de-gua-hao" class="header-anchor">#</a></h2><blockquote>
<p>太菜了，没找准约束条件改了好几次。。。</p>
<p>大致就是利用栈先进后出的特性模拟下对称性</p>
</blockquote>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：0 ms
内存消耗：6.3 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isValid(string s) &#123;
    int start &#x3D; 0, end &#x3D; s.size();
    if (end &#x3D;&#x3D; 0) return true;
    if (end &amp; 1 &#x3D;&#x3D; 1) return false;

    stack&lt;char&gt; bracks;
    char ch;
    while (start !&#x3D; end) &#123;
        ch &#x3D; s.at(start);
        start++;
        switch (ch) &#123;
            case &#39;&#123;&#39;:
            case &#39;[&#39;:
            case &#39;(&#39;:
                bracks.push(ch);
                break;

            case &#39;)&#39;:
                if (!bracks.empty() &amp;&amp; bracks.top() &#x3D;&#x3D; &#39;(&#39;) &#123;
                    bracks.pop();
                &#125; else &#123;
                    return false;
                &#125;
                break;

            case &#39;]&#39;:
                if (!bracks.empty() &amp;&amp; bracks.top() &#x3D;&#x3D; &#39;[&#39;) &#123;
                    bracks.pop();
                &#125; else &#123;
                    return false;
                &#125;
                    break;

            case &#39;&#125;&#39;:
                if (!bracks.empty() &amp;&amp; bracks.top() &#x3D;&#x3D; &#39;&#123;&#39;) &#123;
                    bracks.pop();
                &#125; else &#123;
                    return false;
                &#125;
                break;

            default:
                break;
        &#125;
    &#125;

    if (!bracks.empty()) return false;

    return true;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="21-he-bing-liang-ge-you-xu-lian-biao">21. 合并两个有序链表</span><a href="#21-he-bing-liang-ge-you-xu-lian-biao" class="header-anchor">#</a></h2><blockquote>
<p>算是用空间换时间了</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;
    ListNode *nl &#x3D; new ListNode(-1);
    ListNode *start &#x3D; nl;
    while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;
        if (l1 -&gt; val &lt; l2 -&gt; val) &#123;
            start -&gt; next &#x3D; l1;
            l1 &#x3D; l1 -&gt; next;
        &#125; else &#123;
            start -&gt; next &#x3D; l2;
            l2 &#x3D; l2 -&gt; next;
        &#125;

        start &#x3D; start -&gt; next;
    &#125;

    if (l1 !&#x3D; nullptr) &#123;
        start -&gt; next &#x3D; l1;
    &#125; else &#123;
        start -&gt; next &#x3D; l2;
    &#125;

    return nl -&gt; next;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang">26. 删除排序数组中的重复项</span><a href="#26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：12 ms
内存消耗：7.5 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;
    int resize &#x3D; 1, biao &#x3D; 0;
    int len &#x3D; nums.size();

    if (len &#x3D;&#x3D; 0) return 0;
    if (len &#x3D;&#x3D; 1) return 1;

    for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
        if (nums[i] &#x3D;&#x3D; nums[biao]) &#123;
            continue;
        &#125;
        else &#123;
            nums[resize] &#x3D; nums[i];
            resize++;
            biao &#x3D; i;
        &#125;
    &#125;
    return resize;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="35-sou-suo-cha-ru-wei-zhi">35. 搜索插入位置</span><a href="#35-sou-suo-cha-ru-wei-zhi" class="header-anchor">#</a></h2><blockquote>
<p>二分查找</p>
</blockquote>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：8 ms
内存消耗：6.5 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
    int start &#x3D; 0, end &#x3D; nums.size() - 1, mid;

    if (nums.size() &#x3D;&#x3D; 0) return 0;

    while (start &lt;&#x3D; end) &#123;
        mid &#x3D; (end + start) &gt;&gt; 1;

        if (nums[mid] &#x3D;&#x3D; target) &#123;
            return mid;
        &#125; else if (nums[mid] &lt; target) &#123;
            start &#x3D; mid + 1;
        &#125; else &#123;
            end &#x3D; mid - 1;
        &#125;

    &#125;
    return start;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="58-zui-hou-yi-ge-dan-ci-de-chang-du">58. 最后一个单词的长度</span><a href="#58-zui-hou-yi-ge-dan-ci-de-chang-du" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：0 ms
内存消耗：6.5 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int lengthOfLastWord(string s) &#123;
    if (s.empty()) return 0;

    &#x2F;&#x2F; 清除末尾的空格
    s.erase(0,s.find_first_not_of(&quot; &quot;));
    s.erase(s.find_last_not_of(&quot; &quot;) + 1);

    &#x2F;&#x2F; 切换到第一个字母上
    auto sptr &#x3D; s.rbegin();
    if (*sptr &#x3D;&#x3D; &#39; &#39;) sptr++;

    int len &#x3D; 0;

    &#x2F;&#x2F; 在开头或空格前结束函数
    for (; sptr !&#x3D; s.rend(); sptr++) &#123;
        if (*sptr &#x3D;&#x3D; &#39; &#39;) break;
        else len++;
    &#125;

    return len;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="66-jia-yi">66. 加一</span><a href="#66-jia-yi" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：4 ms
内存消耗：8.9 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;
    int len &#x3D; digits.size() - 1;
    digits[len] +&#x3D; 1;

    if (digits[len] !&#x3D; 10) &#123;
        return digits;
    &#125; else &#123;
        for (int i &#x3D; len; i &gt;&#x3D; 1; i--) &#123;
            if (digits[i] &#x3D;&#x3D; 10) &#123;
                digits[i] -&#x3D; 10;
                digits[i - 1] +&#x3D; 1;
            &#125;
        &#125;

        if (digits[0] &#x3D;&#x3D; 10) &#123;
            digits[0] -&#x3D; 10;
            digits.insert(digits.begin(), 1);
        &#125;
    &#125;
    return digits;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su">83. 删除排序链表中的重复元素</span><a href="#83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：83 ms
内存消耗：17.7 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* deleteDuplicates(ListNode* head) &#123;
    if (head &#x3D;&#x3D; NULL) return head;

    int tmpNum &#x3D; head -&gt; val;

    ListNode *tmp &#x3D; head;
    while (tmp -&gt; next !&#x3D; NULL) &#123;
        if (tmpNum &#x3D;&#x3D; tmp -&gt; next -&gt; val) &#123;
            tmp -&gt; next &#x3D; tmp -&gt; next -&gt; next;
        &#125; else &#123;
            tmpNum &#x3D; tmp -&gt; next -&gt; val;
            tmp &#x3D; tmp -&gt; next;
        &#125;
    &#125;

    return head;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="100-xiang-tong-de-shu">100. 相同的树</span><a href="#100-xiang-tong-de-shu" class="header-anchor">#</a></h2><blockquote>
<p>树这玩意递归就完事了</p>
</blockquote>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时 4 ms
内存消耗：9.9 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;
    if (!p &amp;&amp; !q) return true;

    if (p &#x3D;&#x3D; nullptr || q &#x3D;&#x3D; nullptr) return false;
    if (p -&gt; val !&#x3D; q -&gt; val) return false;

    return isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q-&gt; right);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="101-dui-cheng-er-cha-shu">101. 对称二叉树</span><a href="#101-dui-cheng-er-cha-shu" class="header-anchor">#</a></h2><blockquote>
<p>和上一题差不多，同时比较左右就可以了</p>
</blockquote>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：4 ms
内存消耗：12.4 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isSymmetric(TreeNode* root) &#123;
    if (!root) return true;

    return isSym(root, root);
&#125;

bool isSym(TreeNode *l, TreeNode *r) &#123;
    if (!l &amp;&amp; !r) return true;

    if (l &#x3D;&#x3D; NULL || r &#x3D;&#x3D; NULL) return false;
    if (l -&gt; val !&#x3D; r -&gt; val) return false;

    return isSym(l -&gt; left, r -&gt; right) &amp;&amp; isSym(l -&gt; right, r -&gt; left);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="118-yang-hui-san-jiao">118. 杨辉三角</span><a href="#118-yang-hui-san-jiao" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：0 ms
内存消耗：6.6 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;
    if (numRows &#x3D;&#x3D; 0) return &#123;&#125;;

    vector&lt;vector&lt;int&gt; &gt; ans(numRows, vector&lt;int&gt;(0));
    int layers &#x3D; 1;

    for (int i &#x3D; 1; i &lt;&#x3D; numRows; i++) &#123;
        ans[i - 1].resize(i);
    &#125;

    while (layers &lt;&#x3D; numRows) &#123;
        for (int i &#x3D; 0; i &lt; layers; i++) &#123;
            if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; layers - 1) &#123;
                ans[layers - 1][i] &#x3D; 1;
            &#125; else &#123;
                ans[layers - 1][i] +&#x3D; ans[layers - 2][i] + ans[layers - 2][i - 1];
            &#125;
        &#125;

        layers++;
    &#125;

    return ans;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="459-chong-fu-de-zi-zi-fu-chuan">459. 重复的子字符串</span><a href="#459-chong-fu-de-zi-zi-fu-chuan" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：56 ms
内存消耗：17.7 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool repeatedSubstringPattern(string s) &#123;
    int len &#x3D; s.size();
    if (len &lt;&#x3D; 1) return false;

    bool flag &#x3D; false;
    for (int gaps &#x3D; 1; gaps &lt;&#x3D; len &#x2F; 2; gaps ++) &#123;
        if (len % gaps !&#x3D; 0) continue;

        string basic &#x3D; s.substr(0, gaps);
        for (int i &#x3D; gaps; i &lt; len; i +&#x3D; gaps) &#123;
            string p &#x3D; s.substr(i, gaps);

            if (p !&#x3D; basic) &#123;
                break;
            &#125; else if (p &#x3D;&#x3D; basic &amp;&amp; (i + gaps) !&#x3D; len) &#123;
                continue;
            &#125; else &#123;
                flag &#x3D; true;
            &#125;
        &#125;
    &#125;
    return flag;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="1480-yi-wei-shu-zu-de-dong-tai-he">1480. 一维数组的动态和</span><a href="#1480-yi-wei-shu-zu-de-dong-tai-he" class="header-anchor">#</a></h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">执行用时：4 ms
内存消耗：8.7 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123;
    for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
            nums[i] +&#x3D; nums[i - 1];
    &#125;

    return nums;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'mashiro01';
var disqus_identifier = 'leetcode/index.html';
var disqus_title = 'leetcode';
var disqus_url = 'https://mashiro01.github.io/leetcode/index.html';
(function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//mashiro01.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="https://mashiro01.github.io" rel="noopener noreferrer">Mashiroi</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>